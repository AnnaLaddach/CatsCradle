---
title: "test updates"
output: html_notebook
---

```{r}
load("../data/centroids.rda")
load("../data/smallDelaunayTriangulation.rda")
```

```{r}
library(geometry)
library(Rfast)
```


```{r}
computeNeighboursDelaunayOrig = function(centroids){
    
    ##compute delaunay triangulation
    delaunay = tri.mesh(centroids[,1], centroids[,2])
    
    ##extract triangles from results dataframe
    triangles = delaunay$trlist
    
    results = matrix(nrow = 0, ncol = 2)
    cellNames = rownames(centroids)
    
    ##convert triangle indices to cell names
    triangles[,1] = cellNames[as.numeric(triangles[,1])]
    triangles[,2] = cellNames[as.numeric(triangles[,2])]
    triangles[,3] = cellNames[as.numeric(triangles[,3])]
    
    ##create neighbour list
    for (i in 1:nrow(triangles)){
        results = rbind(results,sort(c(triangles[i,1],triangles[i,2])))
        results = rbind(results,sort(c(triangles[i,1],triangles[i,3])))
        results = rbind(results,sort(c(triangles[i,2],triangles[i,3])))
    }
    
    ##remove duplicate edges
    results = unique(results)
    
    ## Convert to data.frame and name as nodeA, nodeB:
    results = as.data.frame(results)
    names(results) = c('nodeA','nodeB')
    
    return(results)
}

```

```{r}
delaunayNeighbours = computeNeighboursDelaunay(centroids)
delaunayNeighboursOrig = computeNeighboursDelaunayOrig(centroids)
```

```{r}
dim(centroids)[1] == length(unique(c(delaunayNeighbours$nodeA,delaunayNeighbours$nodeB)))
```
```{r}
length(cells)
```
```{r}
dim(centroids)[0]
```


```{r}
dim(delaunayNeighbours)
dim(delaunayNeighboursOrig)
```

```{r}
head(delaunayNeighbours[order(delaunayNeighbours$nodeA,delaunayNeighbours$nodeB),], n = 100)
```
```{r}
head(delaunayNeighboursOrig[order(delaunayNeighboursOrig$nodeA,delaunayNeighboursOrig$nodeB),], n = 100)
```

`

```{r}
delaunayNeighboursOrig[order(delaunayNeighboursOrig$nodeA,delaunayNeighboursOrig$nodeB),] == delaunayNeighbours[order(delaunayNeighbours$nodeA,delaunayNeighbours$nodeB),]
```


```{r}
save(delaunayNeighboursOrig,file = "../data/delaunayNeighboursOrig.rda")
```

```{r}
delaunayNeighboursOrigR = delaunayNeighboursOrig
names(delaunayNeighboursOrigR) = c("nodeB","nodeA")
delaunayNeighboursOrig = rbind(delaunayNeighboursOrig,delaunayNeighboursOrigR[,c(2,1)])
```

```{r}
delaunayNeighboursR = delaunayNeighbours
names(delaunayNeighboursR) = c("nodeB","nodeA")
delaunayNeighbours = rbind(delaunayNeighbours,delaunayNeighboursR[,c(2,1)])
```


```{r}
combined = paste0(delaunayNeighbours$nodeA, "_", delaunayNeighbours$nodeB)
combined_orig = paste0(delaunayNeighboursOrig$nodeA, "_", delaunayNeighboursOrig$nodeB)
```


```{r}
dim(delaunayNeighboursOrig)
```

```{r}
dim(delaunayNeighbours)
```

```{r}
unique(combined[!(combined %in% combined_orig)])
```


```{r}
unique(combined_orig[!(combined_orig %in% combined)])
```

```{r}
computeNeighbourhoodByCTMatrixOrig = function(neighbourhoods, cellTypes){

     cellNames = names(cellTypes)
     neighbourhoodByCT = matrix(nrow = 0, ncol = length(levels(cellTypes)))

     for (neighbourhood in neighbourhoods){
         neighbourhoodByCT = rbind(neighbourhoodByCT,table(cellTypes[neighbourhood]))
     }
     rownames(neighbourhoodByCT) = names(neighbourhoods)

     return(neighbourhoodByCT)
}
```


```{r}
neighbourhoods = computeNeighbourhoods(delaunayNeighbours,
names(clusters))

neighbourhoodbyCTmatrixOrig = computeNeighbourhoodByCTMatrixOrig(neighbourhoods, 
                                                         clusters)
```

```{r}
neighbourhoodbyCTmatrix = computeNeighbourhoodByCTMatrix(delaunayNeighbours,clusters) 
```

```{r}
sum(neighbourhoodbyCTmatrix == neighbourhoodbyCTmatrixOrig)
```

```{r}
dim(neighbourhoodbyCTmatrix)
```

```{r}
36553 * 24
```

```{r}
cellTypesPerCellTypeMatrixOrig = function(nbhdByCellType,seurat_clusters)
{
    clusters = unique(seurat_clusters)
    clusters = clusters[order(clusters)]
    N = length(clusters)
    M = matrix(0,nrow=N,ncol=N)
    Clusters = as.character(clusters)
    rownames(M) = Clusters
    colnames(M) = Clusters

    for(cell in rownames(nbhdByCellType))
    {
        type = as.character(seurat_clusters[cell])
        M[type,] = M[type,] + nbhdByCellType[cell,]
    }

    rowTotals = rowSums(M)
    MM = M
    for(i in 1:nrow(M))
        MM[i,] = MM[i,]  / rowTotals[i]

    return(MM)
}
```


```{r}
cellTypeMatrixOrig = cellTypesPerCellTypeMatrixOrig(neighbourhoodbyCTmatrix,clusters)
```

```{r}
cellTypeMatrix = cellTypesPerCellTypeMatrix(neighbourhoodbyCTmatrix,clusters)
```

```{r}
dim(cellTypeMatrix)
```
```{r}
cellTypesPerCellTypeGraphFromMatrix(cellTypeMatrix)
```
```{r}
cellTypesPerCellTypeGraph(neighbourhoodbyCTmatrix, clusters)
```
```{r}
library(data.table)
```
```{r}
delaunayNeighbours2 = data.table(delaunayNeighbours)
```


```{r}
spatialGraph = delaunayNeighbours
```


```{r}
findCombinatorialNeighbourhoodsNew  = function(spatialGraph, n){
  spatialGraph = data.table(spatialGraph)
  
  spatialGraphR = spatialGraph
  names(spatialGraphR) = c("nodeB","nodeA")
  spatialGraph = rbind(spatialGraph,spatialGraphR[,c(2,1)])
  neighbours = list()
  neighbours[[1]] = spatialGraph
  
  for (i in (2:n)){
    print(i)
    graph = merge(neighbours[[i-1]], neighbours[[1]], by.x = "nodeB", by.y = "nodeA", allow.cartesian = T)
    graph = graph[,c("nodeA","nodeB.y")]
    names(graph) = c("nodeA","nodeB")
    graph = unique(graph)
    orig = c(paste0(neighbours[[i-1]]$nodeB,"_",neighbours[[i-1]]$nodeA))#,paste0(neighbours[[i-1]]$nodeA,"_",neighbours[[i-1]]$nodeB))
    if (i > 2){
      orig = c(orig,paste0(neighbours[[i-2]]$nodeB,"_",neighbours[[i-2]]$nodeA))#, paste0(neighbours[[i-2]]$nodeA,"_",neighbours[[i-2]]$nodeB))
    }
    graph = graph[graph$nodeA != graph$nodeB,]
    new = paste0(graph$nodeA,"_",graph$nodeB)
    graph = graph[!(new %in% orig),]
    #print(table(new %in% orig))
   # print(dim(graph))
    neighbours[[i]] = graph
  }
  return(neighbours)
}
```




```{r}
origCN = findCombinatorialNeighbourhoods(smallDelaunayTriangulation,4)
```

```{r}
newCN = findCombinatorialNeighbourhoodsNew(smallDelaunayTriangulation,4)
```
```{r}
CNBig = findCombinatorialNeighbourhoodsNew(delaunayNeighbours,4)
```


```{r}
CNGraph = reduceCombinatorialBalls(origCN)
```

```{r}
CNGraphNew = rbind(newCN[[1]],newCN[[2]],newCN[[3]],newCN[[4]])
```

```{r}
CNGraphNew = CNGraphNew[CNGraphNew$nodeA != CNGraphNew$nodeB,] 
```

```{r}
table(paste0(CNGraph$nodeA,"_",CNGraph$nodeB) %in% paste0(CNGraphNew$nodeA,"_",CNGraphNew$nodeB)) 
```


```{r}
table(paste0(newCN[[1]]$nodeA,"_",newCN[[1]]$nodeB) %in% paste0(newCN[[2]]$nodeA,"_",newCN[[2]]$nodeB))
```


```{r}
table(paste0(newCN[[2]]$nodeA,"_",newCN[[2]]$nodeB) %in% paste0(newCN[[3]]$nodeA,"_",newCN[[3]]$nodeB))
```
```{r}
table(paste0(newCN[[3]]$nodeA,"_",newCN[[3]]$nodeB) %in% paste0(newCN[[4]]$nodeA,"_",newCN[[4]]$nodeB))
```
```{r}
table(paste0(newCN[[1]]$nodeA,"_",newCN[[1]]$nodeB) %in% paste0(newCN[[4]]$nodeA,"_",newCN[[4]]$nodeB))
```



```{r}
table(paste0(newCN[[1]]$nodeA,"_",newCN[[1]]$nodeB) %in% paste0(newCN[[3]]$nodeA,"_",newCN[[3]]$nodeB))
```




```{r}
table(paste0(newCN[[2]]$nodeA,"_",newCN[[2]]$nodeB) %in% paste0(newCN[[4]]$nodeA,"_",newCN[[4]]$nodeB))
```




```{r}
table(paste0(CNBig[[2]]$nodeA,"_",CNBig[[2]]$nodeB) %in% paste0(CNBig[[3]]$nodeA,"_",CNBig[[3]]$nodeB))
```
```{r}
table(paste0(CNBig[[3]]$nodeA,"_",CNBig[[3]]$nodeB) %in% paste0(CNBig[[4]]$nodeA,"_",CNBig[[4]]$nodeB))
```
```{r}
table(paste0(CNBig[[1]]$nodeA,"_",CNBig[[1]]$nodeB) %in% paste0(CNBig[[4]]$nodeA,"_",CNBig[[4]]$nodeB))
```



```{r}
table(paste0(CNBig[[1]]$nodeA,"_",CNBig[[1]]$nodeB) %in% paste0(CNBig[[3]]$nodeA,"_",CNBig[[3]]$nodeB))
```




```{r}
table(paste0(newCN[[2]]$nodeA,"_",newCN[[2]]$nodeB) %in% paste0(newCN[[4]]$nodeA,"_",newCN[[4]]$nodeB))
```


```{r}
new = paste0(CNGraphNew$nodeA,"_",CNGraphNew$nodeB)
orig = paste0(CNGraph$nodeB,"_",CNGraph$nodeA)
```


```{r}
print(dim(CNGraphNew))
print(dim(unique(CNGraphNew))) 
```


```{r}
table(new %in% orig)
```

```{r}
table(orig %in% new)
```


```{r}
table(new %in% new)
```
```{r}unique
?
```


```{r}
neighbours = findCombinatorialNeighbourhoods(spatialGraph, 4)
```

```{r}
largeCentroids = xenium.obj[["fov"]]@boundaries[["centroids"]]@coords
```

```{r}
rm(xenium.obj)
gc()
```


```{r}
rownames(largeCentroids) = 1:length(largeCentroids[,1]) 
spatialGraph = computeNeighboursDelaunay(largeCentroids)
```

```{r}
neighbours = findCombinatorialNeighbourhoods(spatialGraph, 4)
```



```{r}
dim(neighbours[[i]])
```


```{r}
test = merge(delaunayNeighbours2, delaunayNeighbours2, by.x = "nodeB", by.y = "nodeA", all.x = T, allow.cartesian = T)
```

```{r}
test2 = merge(test, delaunayNeighbours2, by.x = "nodeB.y", by.y = "nodeA", all.y = T,allow.cartesian = T)
```

```{r}
second_neighbours = unique(test[,c("nodeA","nodeB.y")])
```

```{r}
names(second_neighbours) = c("nodeA","nodeB")


first_
second_neighbours[!(second_neighbours %in% delaunayNeighbours2)]
```


```{r}
computeNeighboursEuclidean = function(centroids, threshold){
    colnames(centroids) = c("x","y")
    #results = matrix(nrow = 0, ncol = 2)
    results = list()
    for (i in 1:nrow(centroids)){
        cellX = centroids[i,1]
        cellY = centroids[i,2]
        cellName = rownames(centroids)[i]
        
        ##only calculate distances for cells that could be within distance threshold.
        possibleNeighbours = centroids[(centroids[,"x"] < (cellX + threshold)) &
                                       (centroids[,"x"] > (cellX - threshold)) &
                                       (centroids[,"y"] < (cellY + threshold)) &
                                       (centroids[,"y"] > (cellY - threshold)),,
                                       drop = FALSE]
        
        neighbours = rownames(possibleNeighbours)[cdist(centroids[i,,drop=FALSE]
                                                       ,possibleNeighbours,)[1,] < threshold]
        results[[i]] = cbind(cellName, neighbours)
        
  
    }
    ##remove duplicate edges
    results = unique(results)
    
    ## Convert to data.frame and name as nodeA, nodeB:
    results = as.data.frame(results)
    names(results) = c('nodeA','nodeB')
    
    return(results)
}

```

```{r}
computeNeighboursEuclidean = function(centroids, threshold){
    colnames(centroids) = c("x","y")
    #results = matrix(nrow = 0, ncol = 2)
    results = list()
    
    calculateNeighbours = function()
    for (i in 1:nrow(centroids)){
        cellX = centroids[i,1]
        cellY = centroids[i,2]
        cellName = rownames(centroids)[i]
        
        ##only calculate distances for cells that could be within distance threshold.
        possibleNeighbours = centroids[(centroids[,"x"] < (cellX + threshold)) &
                                       (centroids[,"x"] > (cellX - threshold)) &
                                       (centroids[,"y"] < (cellY + threshold)) &
                                       (centroids[,"y"] > (cellY - threshold)),,
                                       drop = FALSE]
        
        neighbours = rownames(possibleNeighbours)[cdist(centroids[i,,drop=FALSE]
                                                       ,possibleNeighbours,)[1,] < threshold]
        results[[i]] = cbind(cellName, neighbours)
        
  
    }
    ##remove duplicate edges
    results = unique(results)
    
    ## Convert to data.frame and name as nodeA, nodeB:
    results = as.data.frame(results)
    names(results) = c('nodeA','nodeB')
    
    return(results)
}

```

```{r}
for (i in 1:nrow(centroids)){
  a = 1
}
```

```{r}
d = pdist(centroids)
```


```{r}
computeNeighboursEuclideanNew = function(centroids, threshold){
  colnames(centroids) = c("x","y")
  maxX = max(centroids[,"x"])
  minX = min(centroids[,"x"])
  maxY = max(centroids[,"y"])
  minY = min(centroids[,"y"])
  XStep = (maxX - minX)/10
  YStep = (maxY - minY)/10
  results = list()
  k = 1
  for (i in 0:9){
    for (j in 0:9){
      x1 = i * XStep + minX 
      x2 = x1 + 2*XStep
      y1 = j * YStep + minY 
      y2 = y1 + 2*YStep
      selected = centroids[(centroids[,"x"] >= x1) & (centroids[,"x"] <= x2) & (centroids[,"y"] >= y1) & (centroids[,"y"] <= y2), ]
      distances = pdist(selected) 
      distances = reshape2::melt(distances)
      distances = distances[distances$value < threshold,]
      distances = distances[,c(1,2)]
      distances =  rowSort(as.matrix(distances))
      distances[,1] = rownames(selected)[distances[,1]]
      distances[,2] = rownames(selected)[as.numeric(distances[,2])]
    
      results[[k]] = distances
      k = k+1
    }
  }
  
  results = do.call(rbind, results)
  results = unique(results)
  colnames(results) = c("nodeA", "nodeB")
  results = results[results[,"nodeA"] != results[,"nodeB"],]
  results = as.data.frame(results)
  return(results)
}
```

```{r}
t1 = Sys.time()
euclideanNew = computeNeighboursEuclideanNew(centroids, 20)
t2 = Sys.time()
print(t2-t1)
```
```{r}
t1 = Sys.time()
euclideanOrig = computeNeighboursEuclidean(centroids, 20)
t2 = Sys.time()
print(t2-t1)
```


```{r}
head(euclideanNew)
```



```{r}
head(euclideanOrig)
```
```{r}
dim(euclideanOrig)
```

```{r}
dim(euclideanNew)
```
```{r}
orig = paste0(euclideanOrig$nodeA, "_", euclideanOrig$nodeB)
new = paste0(euclideanNew[,"nodeA"], "_", euclideanNew[,"nodeB"])
```

```{r}
table(orig %in% new)
```

```{r}
table(new %in% orig)
```
```{r}
orig[!(orig %in% new)]
```
```{r}
new[!(new %in% orig)]
```
```{r}
"7_4537" %in% new
```

