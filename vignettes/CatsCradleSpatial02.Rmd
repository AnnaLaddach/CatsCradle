---
title: "Cats Cradle Spatial Vignette"
author: "Anna Laddach and Michael Shapiro"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{CatsCradleSpatial02}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, warning = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    fig.dim = c(6,6),
    comment = "#>"
)
```


## Introduction

### Cats Cradle: cells and genes

Cats Cradle exploits the duality between cells and genes.  A standard
Seurat analysis is based on a genes-by-cells matrix, that is, a matrix
whose rows correspond to genes, whose columns correspond to cells and
whose entries give the expression of each gene in each cell.
Typically, one clusters the cells and displays the resulting cell
types on a dimension reduction such as UMAP.

Cats Cradle exploits the duality by transposing the matrix so that
rows correspond to cells and columns correspond to genes.  This allows
one to cluster the genes and display the resulting gene types on a
UMAP of genes.

### Spatial Cats Cradle: neighbourhoods and cell types

Adding spatial information to this mix allows an additional level of
analysis.  Here the role of individual cells is played by sets of
cells (i.e., spatial neighbourhoods) and the role of genes is played
by types of cells in each neighbourhood.  (We'll say more about
neighbourhoods in a moment.)  The underlying data is now a matrix
whose rows correspond to cell types and whose columns correspond
to neighbourhoods.  Each entry gives the number of cells of a given cell
type in each neighbourhood.  With poetic license, we can say that a
neighbourhood "expresses" cell types.

One can then cluster neighbourhoods on the basis of the cell
types. That is, neighbourhoods are clustered into types based on the
mix of cell types that they contain.  One also has a UMAP of
neighbourhoods based on their cell type mix.

Exploiting the duality between neighbourhoods and cell types, we can
also produce a Seurat object whose rows are neighbourhoods and whose
columns columns are cell types.  This allows one to cluster the cell
types.  Cell types then cluster together if they associated into the
same sorts of neighbourhoods.

## Neighbourhoods

A neighbourhood is simply a set of cells.  For our puposes, we will
take it to be a spatially contiguous set of cells, though
mathematically, this is not necessary.  Here we exhibit several ways
of aggregating cells into neigbourhoods based on their spatial
locations.

First load the spatial data:
```{r}
library(Seurat)
#xenium.obj = read.rds("/path/to/xenium.obj.rds")

load("../data/smallXenium.rda")
```

To illustrate this concept we use a subset of a xenium data set that
profiles the mouse hippocampus available from 10x genomics
(https://www.10xgenomics.com/datasets/fresh-frozen-mouse-brain-for-xenium-explorer-demo-1-standard)

We will now visualise this dataset coloured by cell population. Here cell clusters  (louvain cluster) have been assigned cell type identities using RCTD along with a reference dataset (https://www.dropbox.com/s/cuowvm4vrf65pvq/allen_cortex.rds?dl=1) followed by minimal manual curation. Please note these assignments are not definitive and are for illustratory purporses only. 

```{r}
ImageDimPlot(smallXenium, cols = "polychrome", size = 1)
```

To calculate neighbourhoods we will extract centroids for each cell.

```{r}
centroids = GetTissueCoordinates(smallXenium)
rownames(centroids) = centroids$cell
```

Additionally we will extract information on celltype or cluster.
```{r}
clusters = smallXenium@active.ident
```


### Nearest neighbour graphs:

The centroids of the cells are given as points in the plane. Delaunay
triangulation discovers an optimal way of connecting each of these
points to its neighbours.  For each cell in the spatial Seurat object
the following discovers its neighbours based on this Delaunay
triangulation:

Compute spatial neighbours based on Delaunay triangulation.
```{r}
library(CatsCradle)
delaunayNeighbours = computeNeighboursDelaunay(centroids)
```

Another way to compute the neighbours of a given cell is to simply ask
for all the cells within a fixed (Euclidean) distance of that cell:

```{r}
euclideanNeighbours = computeNeighboursEuclidean(centroids,
threshold=20)
```


Notice that when using this spatial nearest neighbours method each
neighbourhood corresponds to an individual cell - it is the
neighbourhood around that cell.  Also note that these neighbourhoods
are not disjoint.  We speculate that Delaunay neighbourhoods are more
appropriate for investigating cell-cell interactions while Euclidean
neighbourhoods are more appropriate for investigating diffusible
ligands.

### nth degree neighbour graphs

Given any graph calculated to report neighbours of degree one, it is now 
possible to extend this to neighbours up to a higher degree (n).  

```{r}
extendedNeighboursList = getExtendedNBHDs(delaunayNeighbours, 4)
```
This returns a list of neighbour graphs where the first item 
(expandedNeighbours[[1]]) is the graph of 1st degree neighbours, the second item
the graph of 2nd degree neighbours e.t.c.

We can now collapse this to obtain a graph that contains the all neighbours up to and including degree 4 (for example).

```{r}
extendedNeighbours = collapseExtendedNBHDs(extendedNeighboursList, 4)
```


## Calculation of neighbourhood celltype composition 

Given any of the spatial graphs describing neighbourhoods calculated above,
we can now calculate the cell type composition of neighbourhoods.

```{r}
NBHDByCTMatrix = computeNBHDByCTMatrix(delaunayNeighbours, clusters)
```

In the resulting matrix neighbourhoods are rows and cell types are columns. 
The values in the matrix indicate the number of cells of a given type within a 
neighbourhood. Note that not all seurat_clusters of the full spatial
Seurat object appear in the subset we are working with.  The resulting
neighbourhoodByCTMatrix lists only those cell types that actually appear.

Let's do the same for our extended neighbourhoods.
```{r}
NBHDByCTMatrixExtended = 
  computeNBHDByCTMatrix(extendedNeighbours, clusters)
```

## Analysis of contact based interactions between cell types

We can go on to calculate a matrix which gives the fraction of contacts cells of
a given type make with cells of another cell type.
```{r}
cellTypesPerCellTypeMatrix = 
  computeCellTypesPerCellTypeMatrix(NBHDByCTMatrix,clusters)
```

Rows and columns both correspond to cell types, but they are playing
different roles.  For a given row (say, cell type A) the entry in
column B represents the fraction of cells in neighbourhoods of cells
of type A that are of type B.

We can then display this as a force directed graph. Here we choose only to 
display contact based interactions that constitute at least 5% of a cell type's
interactions. Of note, this graph is directed as, for example, 50% of cell type
A's interactions might be with cell type B, but only 5% of cell type B's 
interactions might be with cell type A.   
```{r}
colours = DiscretePalette(length(levels(clusters)), palette = "polychrome")
names(colours) = levels(clusters)

cellTypesPerCellTypeGraphFromCellMatrix(cellTypesPerCellTypeMatrix, 
                                    minWeight = 0.05, colours = colours)
```

Here arrows are directed from rows to columns. Thus, we see an arrow from
12 to 18 because neighbourhoods of cells of type 12 are composed on
average of ~15% cells of type 18.  We do not see an arrow from 18 to
12 because on average, neighbourhoods of cells of type 18 have only 3%
cells of type 18, which falls below the chosen cutoff.

It's worth pointing out the following. The number of edges from a cell of
type A to a cell of type B is the same as the number of edges from a
cell of type B to a cell of type A.  Thus the matrix of counts of
these edges is symmetric.  However, numbers of cells of types A and B
are not necessarily equal, and this accounts for the assymmetry in the
fractions. 

```{r}
library(pheatmap)
pheatmap(cellTypesPerCellTypeMatrix)
```



Let's do the same for our expanded nighbourhoods.

```{r}
cellTypesPerCellTypeMatrixExtended = computeCellTypesPerCellTypeMatrix(NBHDByCTMatrixExtended,clusters)

cellTypesPerCellTypeGraphFromCellMatrix(cellTypesPerCellTypeMatrixExtended, minWeight = 0.05, colours = colours)
```
We can also calculate p values (one-sided) for whether cell types are more 
commonly neighbours than expected by chance. To do this we compare the actual 
neighbour graph to randomised neighbour graphs where edges are randomised but 
the degree of each vertice is preserved.

```{r}
cellTypesPerCellTypePValues = computeNeighbourEnrichment(delaunayNeighbours, 
                                                     clusters)
```


Let's plot -log10(pvalue)
```{r}
library(pheatmap)
cellTypesPerCellTypePValuesNegLog = -log10(cellTypesPerCellTypePValues)
pheatmap(cellTypesPerCellTypePValuesNegLog)
```

Recall that the entry in row A and column B represents the enrichment
for cells of type B in the neighborhoods of cells of type A.


## Analysis of neighbourhoods based on cell type composition

We can now perform dimensionality reduction and clustering based on 
neighbourhood composition. As the dimensionality of the feature space is 
relatively low (number of cell types) we calculate the UMAP using features
rather than PCs.

```{r}
NBHDByCTSeurat = computeNBHDVsCTSeurat(NBHDByCTMatrix)
```

Add cell type information to the neighbourhoodSeurat object.
```{r}
NBHDByCTSeurat$cellType = clusters
```

Visualise neighbourhood clusters.
```{r}
DimPlot(NBHDByCTSeurat, group.by = c("cellType"), cols = "polychrome", reduction = "umap")
DimPlot(NBHDByCTSeurat, group.by = c("neighbourhood_clusters"), cols = "polychrome", reduction = "umap")
```


We can now add information on neighbourhood clusters to our original xenium object and visualise these on the tissue.
```{r}
smallXenium$NBHDCluster = NBHDByCTSeurat@active.ident
ImageDimPlot(smallXenium, group.by = "NBHDCluster", size = 1, cols = "polychrome")
```

Let's try the same thing with our extended neighbourhoods up to degree 4.
```{r}
NBHDByCTSeuratExtended = computeNBHDVsCTSeurat(NBHDByCTMatrixExtended)
```
Add cell type information to the NBHDByCTSeuratExtended object.
```{r}
NBHDByCTSeuratExtended$cellType = clusters
```

Visualise neighbourhood clusters.
```{r}
DimPlot(NBHDByCTSeuratExtended, group.by = c("cellType"), cols = "polychrome", reduction = "umap")
DimPlot(NBHDByCTSeuratExtended, group.by = c("neighbourhood_clusters"), cols = "polychrome", reduction = "umap")
```
We can now add information on neighbourhood clusters to our original xenium object and visualise these on the tissue.
```{r}
smallXenium$NBHDClusterExtended= 
  NBHDByCTSeuratExtended@active.ident
ImageDimPlot(smallXenium, group.by = c("NBHDClusterExtended"), 
             size = 1, cols = "polychrome")
```


Here we retrieve fewer clusters, and these describe tissue architecture 
rather than small variations in cellular niche.  

We leave it to the user to decide which approach is most applicable to the 
biological question at hand.


## Relating cell type clusters to neighbourhood clusters

We can now ask how clusters defined transcriptomically (cell type)
relate to those defined based on neighbourhoods (cell niche).  Put
differently, each cell has its (transcriptomic) cell type and sits at
the center of a neighbourhood with a given neighbourhood type.  For
each cell type A and each neighbourhood type B, we can ask what
percentage of the time a cell of type A sits at the center of a
neighbourhood of type B.

```{r}
CTByNBHDCluster = table(NBHDByCTSeurat$cellType,NBHDByCTSeurat@active.ident)
CTByNBHDCluster = CTByNBHDCluster/rowSums(CTByNBHDCluster)

rownames(CTByNBHDCluster) = paste0("CellType",rownames(CTByNBHDCluster))
colnames(CTByNBHDCluster) = paste0("NBHDCluster",colnames(CTByNBHDCluster))

pheatmap(CTByNBHDCluster,
      fontsize_row=8,
      fontsize_col=8,
      cellheight=10,
      cellwidth=10)

sankeyFromMatrix(CTByNBHDCluster)
```

This allows us to see which cell types share the same niche (neighbourhood 
clusters). Let's also perform this analysis using the extended neighbourhoods. 


```{r}
CTByNBHDClusterExtended = table(NBHDByCTSeuratExtended$cellType,NBHDByCTSeuratExtended@active.ident)
CTByNBHDClusterExtended = CTByNBHDClusterExtended/rowSums(CTByNBHDClusterExtended)

rownames(CTByNBHDClusterExtended) = paste0("CellType",rownames(CTByNBHDClusterExtended))
colnames(CTByNBHDClusterExtended) = paste0("NBHDCluster",colnames(CTByNBHDClusterExtended))

pheatmap(CTByNBHDClusterExtended,
      fontsize_row=8,
      fontsize_col=8,
      cellheight=10,
      cellwidth=10)

sankeyFromMatrix(CTByNBHDClusterExtended)
```

## Analysing cell types based on their neighbourhoods

Now we perform dimensionality and clustering of cell types, based on the 
neighbourhoods they are found in. Note that this is based on the transpose of 
the matrix used in the previous section.

First we create a seurat object for a cell type by neighbourhood matrix (the 
transposed neighbourhoodByCTMatrix). Here we have a 
large feature space (numbers of cells) however low number of observations 
(number of cell types). Therefore we compute the UMAP using PCs however due to 
the low number of observations we need to set a lower value for n.neighbours.


```{r}
CTByNBHDSeurat = 
  computeNBHDVsCTSeurat(t(NBHDByCTMatrix), npcs = 10, 
                                 transpose = T, resolution = 1, n.neighbors = 5)

CTByNBHDSeurat$cellType = colnames(CTByNBHDSeurat)

DimPlot(CTByNBHDSeurat, group.by = "cellType", cols = "polychrome", 
        reduction = "umap", label = T)
```



Let's perform the same analysis using the extended neighbourhoods.

```{r}
CTByNBHDSeuratExtended = 
  computeNBHDVsCTSeurat(t(NBHDByCTMatrixExtended), npcs = 10, 
                                 transpose = T, resolution = 1, n.neighbors = 5)

CTByNBHDSeuratExtended$cellType = colnames(CTByNBHDSeuratExtended)

DimPlot(CTByNBHDSeuratExtended, group.by = "cellType", cols = "polychrome", 
        reduction = "umap", label = T)
```


We can also compute a graph embedding.
```{r}
CTByNBHDSeurat= computeGraphEmbedding(CTByNBHDSeurat)

DimPlot(CTByNBHDSeurat,group.by = "cellType", cols = "alphabet", reduction = "graph", label = T)
```
```{r}
CTByNBHDSeuratExtended = computeGraphEmbedding(CTByNBHDSeuratExtended)

DimPlot(CTByNBHDSeuratExtended,group.by = "cellType", cols = "alphabet", reduction = "graph", label = T)
```

We achieve only one cluster using the louvain algorithm. Let's try hierachical 
clustering.
```{r}
pca = Embeddings(CTByNBHDSeurat, reduction = "pca")
res = pheatmap(pca)
```

And for expanded neighbourhoods.
```{r}
pcaExtended = Embeddings(CTByNBHDSeuratExtended, reduction = "pca")
resExtended = pheatmap(pcaExtended)
```


Here we decide to cut the tree at the correct level to form 11 clusters.
```{r}
CTClust = cutree(res$tree_row, k = 11)
CTByNBHDSeurat$neighbourhood_clusters = factor(CTClust)
```

Let's investigate how neighbourhood clusters relate to cell type clusters.
```{r}
averageExpMatrix = getAverageExpressionMatrix(NBHDByCTSeurat,
                           CTByNBHDSeurat,
			    clusteringName='neighbourhood_clusters')
averageExpMatrix = tagRowAndColNames(averageExpMatrix,
                                     ccTag='neighbourhoodClusters_',
                                     gcTag='cellTypeClusters_')
pheatmap(averageExpMatrix,
      fontsize_row=8,
      fontsize_col=8,
      cellheight=10,
      cellwidth=10)


sankeyFromMatrix(averageExpMatrix)
```

## Detection of genes with spatially variable expression.

Given a neighbour graph describing the spatial relationships between cells, 
we can compute spatial autocorrelation (here we use Moran's I). This describes
how clustered gene expression values are in space. We derive an upper tail p 
value based on simulations where expression values for genes are permuted. N.B 
in this implementation equal weights are given to all neighbours of a cell.

```{r}
moransI = runMoransI(smallXenium, delaunayNeighbours, assay = "SCT", 
                     layer = "data", nSim = 100)
```
Look at most spatially autocorrelated genes.
```{r}
head(moransI)
```

Look at least spatially autocorrelated genes.
```{r}
tail(moransI)
```

Visualise most spatially autocorrelated gene.
```{r}
ImageFeaturePlot(smallXenium, "Nwd2")
```
Visualise least spatially autocorrelated gene.
```{r}
ImageFeaturePlot(smallXenium, "Trbc2")
```

## Ligand receptor analysis

We can perform an analysis of ligand receptor interactions in order to infer 
communication between cells. 
Here we calculate whether interactions between ligand receptor pairs occur on 
edges of the spatial graph, i.e. between neighbouring cells, where cell A 
expresses a ligand and cell B expresses a receptor. Note that the distance 
between cell A and cell B will vary depending on how the graph has been 
constructed, larger distances may be desired for analyses involving diffusable 
ligands and receptors. We also analyse analyse the number of ligand receptor 
interactions that occur between cells from the same cluster and between cells 
from different clusters. Note that clusters may represent cell type, or another 
property of the cells such as their neighbourhood type. We leave this for the 
user to decide. We then calculate how frequently the number of ligand-receptor 
interactions observed between/within clusters is higher than in simulated data,
this allows us to assign a pvalue for the enrichment of these interactions.

Perform interaction analysis:
```{r}
ligandReceptorResults = performLigandReceptorAnalysis(smallXenium, delaunayNeighbours, 
                                                "mouse", clusters,verbose=FALSE)
```


Look at interactions on edges:
```{r}
head(ligandReceptorResults$interactionsOnEdges,10)
```

Look at total interactions between/within clusters:
```{r}
head(ligandReceptorResults$totalInteractionsByCluster,10)
```

Look at mean interactions per edge between/within clusters:
```{r}
head(ligandReceptorResults$meanInteractionsByCluster,10)
```

Look at number of times observed interactions are more frequent than expected:
```{r}
head(ligandReceptorResults$simResults,10)
```

Look at pvalues for the enrichment of interactions.
```{r}
head(ligandReceptorResults$pValues,10)
```


Plot a heatmap showing -log10(pvalues) for the enrichment of ligand-receptor 
interactions between pairs of clusters. 

```{r}
ligRecMatrix = makeLRInteractionHeatmap(ligandReceptorResults, clusters, colours = colours, labelClusterPairs = F)
```



```{r}
makeLRInteractionHeatmap(ligandReceptorResults, clusters, labelClusterPairs = F)
```


```{r}
cellTypePerCellTypeLigRecMatrix = makeSummedLRInteractionHeatmap(ligandReceptorResults, clusters, "total")
```

```{r}
cellTypePerCellTypeLigRecMatrix = makeSummedLRInteractionHeatmap(ligandReceptorResults, clusters, "mean", logScale = T)
```
```{r}
hist(cellTypePerCellTypeLigRecMatrix)
```
Visualise in graph format.
```{r}
cellTypesPerCellTypeGraphFromCellMatrix(cellTypePerCellTypeLigRecMatrix/5, 
                                    minWeight = 0.08, colours = colours)
```


Create a Seurat object where each point represents an edge between cells, and spatial coordinates are thecentroids of edges between cells. The "expression matrix" is the binarised presence/absence of an interaction (ligand receptor pair) on an edge. This is useful for visualising where ligand receptor interactions occur spatially.
```{r}
edgeSeurat = computeEdgeSeurat(ligandReceptorResults, centroids)
```


Visualise Penk-Htr1f interaction.
```{r}
ImageFeaturePlot(edgeSeurat, features = "Penk-Htr1f")
```

We can compute a spatial graph where edges in the original delaunayNeighbours 
become nodes and A-B edges (in the original graph) become connected to all 
A- edges and all B- edges. This allows us to perfom graph-based associated with 
the spatial localisation of ligand receptor pairs on edges.  
```{r}
edgeNeighbours = computeEdgeGraph(delaunayNeighbours)
```


Compute Moran's I for the spatial autocorrelation of ligand-receptor interactions.
```{r}
moransILigandReceptor = runMoransI(edgeSeurat, edgeNeighbours, assay = "RNA", 
                     layer = "counts", nSim = 100)
use_data(moransILigandReceptor, overwrite = T)
```

View most spatially autocorrelated ligand-receptor interactions.
```{r}
head(moransILigRec)
```

View least spatially autocorrelated ligand-receptor interactions.
```{r}
tail(moransILigRec)
```


View ligand-receptor interaction with the highest spatial autocorrelation (Moran's I).
```{r}
ImageFeaturePlot(edgeSeurat, "Penk-Htr1f")
```

View ligand-receptor interaction with the lowest spatial autocorrelation (Moran's I).
```{r}
ImageFeaturePlot(edgeSeurat, "Sst-Gpr17")
```