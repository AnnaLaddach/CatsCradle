% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleNeighbourhoodAnalysis.R
\name{computeNeighbourEnrichment}
\alias{computeNeighbourEnrichment}
\title{This function calculates P values for whether cell types are more frequently
neighbours than expected by chance.  It offers two distinct randomisations.
One is by permuting the cell types on the neighbour (e.g., delaunay)
graph.  The other is by comparison to randomised  neighbour graphs
where edges are randomised but the degree of each node is
preserved.}
\usage{
computeNeighbourEnrichment(
  spatialGraph,
  cellTypes,
  nSim = 1000,
  maxTries = 1000,
  randomiseBy = "cells",
  verbose = TRUE
)
}
\arguments{
\item{spatialGraph}{\itemize{
\item a spatial graph in neighbour list format.
}}

\item{cellTypes}{\itemize{
\item named vector of cell types where names are each cell and
cell types are a factor.
}}

\item{nSim}{\itemize{
\item the number of randomised graphs to create for pvalue
calculation.
}}

\item{maxTries}{\itemize{
\item the maximum number of tries to remove self edges during
graph randomisation. If self edges are remeining this will be reported.
}}

\item{randomiseBy}{\itemize{
\item This takes either the value 'cells' (the default)
or 'graph'.  In the former case randomisation is carried out by permuting
the cell types on the existing graph.  In the latter case, the graph is
permuted using the function randomiseGraph() which is a heuristic
algorithm to preserve the distribution of vertex degrees.
}}

\item{verbose}{\itemize{
\item whether to print trace.  Defaults to TRUE
}}
}
\value{
A square matrix containing upper tail p values describing
whether two  cell types are more frequently found together than
expected by chance.
}
\description{
This function calculates P values for whether cell types are more frequently
neighbours than expected by chance.  It offers two distinct randomisations.
One is by permuting the cell types on the neighbour (e.g., delaunay)
graph.  The other is by comparison to randomised  neighbour graphs
where edges are randomised but the degree of each node is
preserved.
}
\examples{
getExample = make.getExample()
delaunayNeighbours = getExample('delaunayNeighbours')
clusters = getExample('clusters')
cellTypesPerCellTypePValues = computeNeighbourEnrichment(delaunayNeighbours, 
                                        clusters, nSim = 10, verbose = FALSE)
}
