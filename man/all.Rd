% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{aggregateFeatureMatrix}
\alias{aggregateFeatureMatrix}
\title{This function takes a matrix where rows are features and columns are cells,
and a neighbourhood list, and creates an matrix where columns are the
neighbourhoods, the rows are are the features and the values are aggregated
expression values for cells in each neighbourhood.}
\usage{
aggregateFeatureMatrix(M, nbhdList, aggregateFunction)
}
\arguments{
\item{M}{\itemize{
\item a matrix where column names are cells and row names are
features.
}}

\item{nbhdList}{\itemize{
\item a named list with memberships of the neighbourhoods
of cells
}}

\item{aggregateFunction}{\itemize{
\item a function to aggregate expression (e.g. rowSums,
rowMeans)
}}
}
\value{
a matrix giving aggregated gene expression for a cell's neighbourhood.
}
\description{
This function takes a matrix where rows are features and columns are cells,
and a neighbourhood list, and creates an matrix where columns are the
neighbourhoods, the rows are are the features and the values are aggregated
expression values for cells in each neighbourhood.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{aggregateSeuratGeneExpression}
\alias{aggregateSeuratGeneExpression}
\title{This function takes a Seurat object and a list of
neighbourhoods and creates a Seurat object where the
columns are the neighbourhoods, the rows are are the
genes and the values are gene expression totals for
the cells in each neighbourhood}
\usage{
aggregateSeuratGeneExpression(
  f,
  neighbourhoods,
  verbose = TRUE,
  returnType = "Seurat"
)
}
\arguments{
\item{f}{\itemize{
\item a Seurat object with layer counts or a SingleCellExperiment
to be turned into a Seurat object
}}

\item{neighbourhoods}{\itemize{
\item Neighbourhoods as given by a
collapsed expanded edge graph, as produced by
collapseNeighbourhoods. In particular, each cell should
appear as nodeA.
}}

\item{verbose}{\itemize{
\item used to control trace, defaults to TRUE
}}

\item{returnType}{\itemize{
\item Will return a SingleCellExperiment if this is either
of SCE, SingleCellExperiment or their lower-case equivalents.  Otherwise,
returns a Seurat object or SingleCellExperiment, depending on the
parameter returnType.
}}
}
\value{
a Seurat object giving total gene expression
in each neighbourhood or SingleCellExperiment
}
\description{
This function takes a Seurat object and a list of
neighbourhoods and creates a Seurat object where the
columns are the neighbourhoods, the rows are are the
genes and the values are gene expression totals for
the cells in each neighbourhood
}
\examples{
agg = aggregateSeuratGeneExpression(smallXenium,extendedNeighbours,
verbose=FALSE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{annotateGeneAsVector}
\alias{annotateGeneAsVector}
\title{This function returns a numeric indicating which gene
sets it does and does not belong to.  This vector can
be normalised to account for the sizes of the sets.}
\usage{
annotateGeneAsVector(gene, geneSets, normalise = FALSE)
}
\arguments{
\item{gene}{\itemize{
\item the gene to annotate
}}

\item{geneSets}{\itemize{
\item a list of gene sets
}}

\item{normalise}{\itemize{
\item whether to normalise by set size
}}
}
\value{
a numeric
}
\description{
This function returns a numeric indicating which gene
sets it does and does not belong to.  This vector can
be normalised to account for the sizes of the sets.
}
\examples{
Myc = annotateGeneAsVector('Myc',hallmark)
MycNormalised = annotateGeneAsVector('Myc',hallmark,TRUE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{annotateGenesByGeneSet}
\alias{annotateGenesByGeneSet}
\title{This function annotates genes with terms}
\usage{
annotateGenesByGeneSet(geneSets)
}
\arguments{
\item{geneSets}{\itemize{
\item a list of gene sets, e.g., as produced by
readGmt
}}
}
\value{
\itemize{
\item A list where names are genes and values are lists of terms
}
}
\description{
This essentially inverts a list of gene sets.  It takes
a list (e.g., Hallmark or GO) where each list item is a
name of a gene set and gives the genes in that set and
returns a list where each item is a gene and gives the
gene sets that gene is in.
}
\examples{
annotatedGenes = annotateGenesByGeneSet(hallmark)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{annotateLRInteractionCounts}
\alias{annotateLRInteractionCounts}
\title{This takes a data frame of interaction counts as found
by countLRInteractionsPerCell(), the underlying Seurat object
and the neighbourhood Seurat object and annotates the counts
with the cell type and the neighbourhood type corresponding
to the cells of the interaction counts.}
\usage{
annotateLRInteractionCounts(interactionCounts, obj, nbhdObj)
}
\arguments{
\item{interactionCounts}{\itemize{
\item as found by countLRInteractionsPerCell()
}}

\item{obj}{\itemize{
\item a Seurat object, or SingleCellExperiment to be turned
into a Seurat object
}}

\item{nbhdObj}{\itemize{
\item a neighbourhood x cell type Seurat object or a
SingleCellExperiment to be turned into a Seurat object
}}
}
\value{
This returns the interaction counts annotated with the
cell type and neighbourhood type of each cell.
}
\description{
This takes a data frame of interaction counts as found
by countLRInteractionsPerCell(), the underlying Seurat object
and the neighbourhood Seurat object and annotates the counts
with the cell type and the neighbourhood type corresponding
to the cells of the interaction counts.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{averageExpMatrix}
\alias{averageExpMatrix}
\title{averageExpMatrix}
\format{
A 30 x 13 matrix
\describe{
This gives the average gene expression for each of the
gene clusters in each of the cell clusters.
}
}
\source{
Produced from S and STranspose by
getAverageExpression()
}
\usage{
averageExpMatrix
}
\description{
The average expression matrix for cell clusters of S
and gene clusters of STranspose.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{cellTypesPerCellTypeGraphFromCellMatrix}
\alias{cellTypesPerCellTypeGraphFromCellMatrix}
\title{This function converts a matrix as found by
cellTypesPerCellTypeMatrix into a directed igraph
whose vertices correspond to seurat_clusters and whose
edge correspond to occupancy fraction.}
\usage{
cellTypesPerCellTypeGraphFromCellMatrix(
  M,
  colours = NULL,
  selfEdges = FALSE,
  minWeight = 0,
  edgeWeighting = 20,
  edgeCurved = 0.2,
  arrowSize = 4,
  arrowWidth = 4,
  plotGraph = TRUE
)
}
\arguments{
\item{M}{\itemize{
\item a matrix as found by cellTypesPerCellTypeMatrix. Note,
however, that this matrix may need to be reduced to a square matrix
as the matrix produced from a subset object may be missing certain
cell types as rows.
}}

\item{colours}{\itemize{
\item a named vector of colours used to colour the
vertices of the graph.  The names are the seurat_clusters
as character strings.
}}

\item{selfEdges}{\itemize{
\item a logical which determines whether to include
self edges.  Defaults to FALSE
}}

\item{minWeight}{\itemize{
\item Allows one to exclude edges of low weight.
Defaults to 0, thus including all edges.
}}

\item{edgeWeighting}{\itemize{
\item a parameter used to thicken the edges
in the display.  Defaults to 20.
}}

\item{edgeCurved}{\itemize{
\item a parameter to set curvature of the edges.
Defaults to 0.2
}}

\item{arrowSize}{\itemize{
\item a parameter to set arrow size. Defaults to 4.
}}

\item{arrowWidth}{\itemize{
\item a parameter to set arrow width. Defaults to 4.
}}

\item{plotGraph}{\itemize{
\item a logical which determines whether to
plot the graph.  Defaults to TRUE.
}}
}
\value{
This returns a directed igraph whose vertices are
the cell types and whose arrows indicate "ownership" of
cells of the target type by neighbourhoods of cells of the
source type.  Layout is done witht the FR algorithm and
coordinates are found in G$coords.  If colours were supplied
these are found in V(G)$color.  Edge weights and widths are
found in E(G)$weight and E(G)$width.
}
\description{
This function converts a matrix as found by
cellTypesPerCellTypeMatrix into a directed igraph
whose vertices correspond to seurat_clusters and whose
edge correspond to occupancy fraction.
}
\examples{
G = cellTypesPerCellTypeGraphFromCellMatrix(cellTypesPerCellTypeMatrix, 
minWeight = 0.05, colours = colours)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{cellTypesPerCellTypeGraphFromNbhdMatrix}
\alias{cellTypesPerCellTypeGraphFromNbhdMatrix}
\title{This function takes a neighbourhood-by-cell type
matrix and produces a directed igraph showing the
fractions of cells of each type in the neighbourhoods
around cells of each type.}
\usage{
cellTypesPerCellTypeGraphFromNbhdMatrix(
  nbhdByCellType,
  clusters,
  colours = NULL,
  selfEdges = FALSE,
  minWeight = 0,
  edgeWeighting = 20,
  edgeCurved = 0.2,
  arrowSize = 4,
  arrowWidth = 4,
  plotGraph = TRUE
)
}
\arguments{
\item{nbhdByCellType}{\itemize{
\item A matrix whose rows are neighbourhoods
each denoted by the cell at their center, whose columns are
cell types, and whose entries are counts.
}}

\item{clusters}{\itemize{
\item a named vector whose names are the cells
and whose entries are their seurat_clusters.
}}

\item{colours}{\itemize{
\item a named vector of colours used to colour the
vertices of the graph.  The names are the seurat_clusters
as character strings.
}}

\item{selfEdges}{\itemize{
\item a logical which determines whether to include
self edges.  Defaults to FALSE
}}

\item{minWeight}{\itemize{
\item Allows one to exclude edges of low weight.
Defaults to 0, thus including all edges.
}}

\item{edgeWeighting}{\itemize{
\item a parameter used to thicken the edges
in the display.  Defaults to 20.
}}

\item{edgeCurved}{\itemize{
\item a parameter to set curvature of the edges.
Defaults to 0.2
}}

\item{arrowSize}{\itemize{
\item a parameter to set arrow size. Defaults to 4.
}}

\item{arrowWidth}{\itemize{
\item a parameter to set arrow width. Defaults to 4.
}}

\item{plotGraph}{\itemize{
\item a logical which determines whether to
plot the graph.  Defaults to TRUE.
}}
}
\value{
This returns a directed igraph whose vertices are
the cell types and whose arrows indicate "ownership" of
cells of the target type by neighbourhoods of cells of the
source type.  Layout is done witht the FR algorithm and
coordinates are found in G$coords.  If colours were supplied
these are found in V(G)$color.  Edge weights and widths are
found in E(G)$weight and E(G)$width.
}
\description{
This function takes a neighbourhood-by-cell type
matrix and produces a directed igraph showing the
fractions of cells of each type in the neighbourhoods
around cells of each type.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{cellTypesPerCellTypeMatrixExtended}
\alias{cellTypesPerCellTypeMatrixExtended}
\title{cellTypesPerCellTypeMatrixExtended}
\format{
A matrix whose rows and columns correspond to
cell types.

\describe{
Each row of this matrix corresponds to a cell type.  On
that row we see the proportions of all neighbourhoods
surrounding cells of that cell type as regards the cell types
they contain.  In particular, each row sums to 1.  This uses
the extended neighbourhoods of combinatorial radius 4.
}
}
\source{
This is created from NBHDByCTMatrixExtended and the
clusters using cellTypesPerCellTypeMatrix()
}
\usage{
cellTypesPerCellTypeMatrixExtended
}
\description{
For each cell type, this matrix shows the fraction
of the neighbourhoods of that cell type composed of
each cell type. This uses the extended neighbourhoods
of combinatorial radius 4
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{cellTypesPerCellTypeMatrix}
\alias{cellTypesPerCellTypeMatrix}
\title{cellTypesPerCellTypeMatrix}
\format{
A matrix whose rows and columns correspond to
cell types.

\describe{
Each row of this matrix corresponds to a cell type.  On
that row we see the proportions of all neighbourhoods
surrounding cells of that cell type as regards the cell types
they contain.  In particular, each row sums to 1.
}

A matrix whose rows and columns correspond to
cell types.

\describe{
Each row of this matrix corresponds to a cell type.  On
that row we see the proportions of all neighbourhoods
surrounding cells of that cell type as regards the cell types
they contain.  In particular, each row sums to 1.
}
}
\source{
This is created from NBHDByCTMatrix and the clusters
using cellTypesPerCellTypeMatrix()

This is created from NBHDByCTMatrixExtended and the clusters
using cellTypesPerCellTypeMatrix()
}
\usage{
cellTypesPerCellTypeMatrix

cellTypesPerCellTypeMatrix
}
\description{
For each cell type, this matrix shows the fraction
of the neighbourhoods of that cell type composed of
each cell type.

For each cell type, this matrix shows the fraction
of the extended neighbourhoods of that cell type composed of
each cell type.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{cellTypesPerCellTypePValues}
\alias{cellTypesPerCellTypePValues}
\title{cellTypesPerCellTypePValues
A symmetric matrix containing P values describing whether cell types are more
frequently neighbours than expected by chance.}
\format{
A matrix whose rows and columns correspond to
cell types.

\describe{
Rows and columns of this matrix correspond to a cell types. Matrix give p
values describing whether cell types are more frequently neighbours than
expected by chance.
}
}
\source{
This is created from delaunayNeighbours and the clusters
using computeNeighbourEnrichment()
}
\usage{
cellTypesPerCellTypePValues
}
\description{
cellTypesPerCellTypePValues
A symmetric matrix containing P values describing whether cell types are more
frequently neighbours than expected by chance.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{centroids}
\alias{centroids}
\title{centroids}
\format{
a dataframe
where rownames are cellnames and columns contain x
and y coordinates respectively.
\describe{
This gives the x and y coordinates for cell centroids from xenium
mouse brain spatial data.
}
}
\source{
subset of tiny subset from
https://www.10xgenomics.com/resources/datasets/fresh-frozen-mouse-brain-for-xenium-explorer-demo-1-standard
}
\usage{
centroids
}
\description{
Cell centroids from xenium spatial data
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{clusterDF}
\alias{clusterDF}
\title{clusterDF}
\format{
A data frame with columns gene and geneCluster
\describe{
This gives the cluster membership of the genes of STranspose.
}
}
\source{
Extracted from STranspose
}
\usage{
clusterDF
}
\description{
A data frame of genes and their gene cluster membership
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{clusters}
\alias{clusters}
\title{clusters}
\format{
a named vector of cluster where names are each cell and
clusters are a factor.
\describe{
This contains cluster annotations for xenium mouse brain data extracted from
a Seurat analysis.
}
}
\source{
clusters from Seurat analysis of subset of
https://www.10xgenomics.com/resources/datasets/fresh-frozen-mouse-brain-for-xenium-explorer-demo-1-standard
}
\usage{
clusters
}
\description{
Clusters from xenium spatial data
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{collapseExtendedNBHDs}
\alias{collapseExtendedNBHDs}
\title{This function takes an expanded neighbourhood list and collapses it to a
nearest neighbourhood graph where all neighbours of degree <= n in the
original graph are considered first neighbours.}
\usage{
collapseExtendedNBHDs(
  extendedNeighboursList,
  n = length(extendedNeighboursList)
)
}
\arguments{
\item{extendedNeighboursList}{\itemize{
\item the results of getExtendedNBHDs()
}}

\item{n}{\itemize{
\item the maximum degree to connect neighbours. Defaults to the maximum
degree neighbourhoods were expanded to in the results of getExtendedNBHDs().
}}
}
\value{
a graph in neighbour format, i.e., a data frame with
columns nodeA and nodeB, where nodes that were originally of degree <= n
are connected.
}
\description{
This function takes an expanded neighbourhood list and collapses it to a
nearest neighbourhood graph where all neighbours of degree <= n in the
original graph are considered first neighbours.
}
\examples{
extendedNeighbours = collapseExtendedNBHDs(extendedNeighboursList, 4)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{colours}
\alias{colours}
\title{colours}
\format{
A character vector of colours where names are clusters.

\describe{
A character vector of colours from the polychrome palette where names
are clusters.
}
}
\source{
Created using Seurat DiscretePalette()
}
\usage{
colours
}
\description{
A character vector of colours where names are clusters.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{combinatorialSpheres}
\alias{combinatorialSpheres}
\title{Discovers the combinatorial ball of a given radius
around a fixed set of genes in the nearest neighbor
graph of a Seurat object.}
\usage{
combinatorialSpheres(NN, origin, radius)
}
\arguments{
\item{NN}{\itemize{
\item a nearest neighbors graph
}}

\item{origin}{\itemize{
\item a gene or list of genes
}}

\item{radius}{\itemize{
\item the radius of the combinatorial ball
to be found.
}}
}
\value{
This returns a data frame whose columns are the
gene name, the radius from the origin at which it is found
}
\description{
Discovers the combinatorial ball of a given radius
around a fixed set of genes in the nearest neighbor
graph of a Seurat object.
}
\examples{
spheres = combinatorialSpheres(NN,'Ccl6',3)
geneSet = intersect(hallmark[[1]],colnames(STranspose))
sphereAroundSet = combinatorialSpheres(NN,geneSet,1)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeCellTypesPerCellTypeMatrix}
\alias{computeCellTypesPerCellTypeMatrix}
\title{For each cell type, this function looks at the neighbourhoods
around cells of that type and discovers the fractions of those
cells of each type.}
\usage{
computeCellTypesPerCellTypeMatrix(nbhdByCellType, cellTypes)
}
\arguments{
\item{nbhdByCellType}{\itemize{
\item A matrix whose rows are neighbourhoods
each denoted by the cell at their center, whose columns are
cell types, and whose entries are counts.
}}

\item{cellTypes}{\itemize{
\item named vector of cell types where names are each cell and
cell types are a factor
}}
}
\value{
A square matrix whose rownames and colnames are the
seurat_clusters as character strings.  Each row corresponds
to neighbourhoods around all cells of that type and the entries
give the fractions of those neighbourhoods occupied by cells
of each type.
}
\description{
For each cell type, this function looks at the neighbourhoods
around cells of that type and discovers the fractions of those
cells of each type.
}
\examples{
cellTypesPerCellType = computeCellTypesPerCellTypeMatrix(NBHDByCTMatrix,
                                                     clusters)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeEdgeGraph}
\alias{computeEdgeGraph}
\title{This function takes a spatial graph and computes a new spatial graph where
edges become nodes and A-B edges (in the original graph) become connected to
all A- edges and all B- edges.}
\usage{
computeEdgeGraph(spatialGraph, selfEdges = FALSE)
}
\arguments{
\item{spatialGraph}{\itemize{
\item a data frame of neighbouring edge pairs.
}}

\item{selfEdges}{\itemize{
\item a logical determining whether to include self edges.
Defaults to False.
}}
}
\value{
a graph in neighbour format  where edges in the original graph
become nodes and A-B edges (in the original graph) become connected to
all A- edges and all B- edges.
}
\description{
This function takes a spatial graph and computes a new spatial graph where
edges become nodes and A-B edges (in the original graph) become connected to
all A- edges and all B- edges.
}
\examples{
edgeNeighbours = computeEdgeGraph(delaunayNeighbours)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeEdgeSeurat}
\alias{computeEdgeSeurat}
\title{This function takes interactionResults and creates a seurat object where
each point represents an edge between cells, and spatial coordinates are the
centroids of edges between cells. The "expression matrix" is the
binarised presence/absence of an interaction (ligand receptor pair) on an edge.}
\usage{
computeEdgeSeurat(
  ligandReceptorResults,
  centroids,
  npcs = 10,
  returnType = "Seurat"
)
}
\arguments{
\item{ligandReceptorResults}{\itemize{
\item as returned by performLigandReceptorResultsAnalysis()
}}

\item{centroids}{\itemize{
\item a dataframe containing centroids
where rownames are cellnames and the first two columns
contain x and y coordinates respectively.
}}

\item{npcs}{\itemize{
\item number of pcs used for PCA, defaults to 10
}}

\item{returnType}{Determines whether to return a Seurat object or a
SpatialExperiment.  Will do the later if this is set to either SCE,
SingleCellExperiment or lower case versions of either.}
}
\value{
This returns a seurat object where
each point represents an edge between cells, and spatial coordinates are the
centroids of edges between cells. The "expression matrix" is the
binarised presence/absence of an interaction (ligand receptor pair) on an edge.
Depending on the parameter returnType, this can alternatively be returned as
a SpatialExperiment.
}
\description{
This function takes interactionResults and creates a seurat object where
each point represents an edge between cells, and spatial coordinates are the
centroids of edges between cells. The "expression matrix" is the
binarised presence/absence of an interaction (ligand receptor pair) on an edge.
}
\examples{
edgeSeurat = computeEdgeSeurat(ligandReceptorResults, centroids)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeGraphEmbedding}
\alias{computeGraphEmbedding}
\title{This function adds a force directed graph embedding to a seurat object}
\usage{
computeGraphEmbedding(
  seuratObj,
  graph = defaultGraph(seuratObj),
  returnType = "Seurat"
)
}
\arguments{
\item{seuratObj}{\itemize{
\item a seurat object of SingleCellExperiment to be
turned into a Seurat object
}}

\item{graph}{\itemize{
\item which graph to extract.  Defaults to
paste0(f@active.assay,'_snn')
}}

\item{returnType}{\itemize{
\item Will return a SingleCellExperiment if this is either
of SCE, SingleCellExperiment or their lower-case equivalents.  Otherwise,
returns a Seurat object
}}
}
\value{
a seurat object with a "graph" dimensionality reduction. Can also
be a SingleCellExperiment depending on parameter returnType.
}
\description{
This function adds a force directed graph embedding to a seurat object
}
\examples{
objWithEmbedding = computeGraphEmbedding(NBHDByCTSeurat)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeMoransI}
\alias{computeMoransI}
\title{This function takes a matrix where rows are features and columns are cells,
and a neighbourhood list, and computes Moran's I.}
\usage{
computeMoransI(M, nbhdList)
}
\arguments{
\item{M}{\itemize{
\item a matrix where column names are cells and row names are features.
}}

\item{nbhdList}{\itemize{
\item a named list with memberships of the neighbourhoods
of cells
rowMeans)
}}
}
\value{
a matrix giving aggregated gene expression for a cell's neighbourhood.
}
\description{
This function takes a matrix where rows are features and columns are cells,
and a neighbourhood list, and computes Moran's I.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeNBHDByCTMatrix}
\alias{computeNBHDByCTMatrix}
\title{This function computes a matrix where neighbourhoods are rows and
cell types are columns. The values in the matrix indicate the
number of cells of a given type within a neighbourhood.}
\usage{
computeNBHDByCTMatrix(spatialGraph, cellTypes)
}
\arguments{
\item{spatialGraph}{\itemize{
\item a spatial graph in neighbour list format.
}}

\item{cellTypes}{\itemize{
\item named vector of cell types where names are each cell and
cell types are a factor
}}
}
\value{
a matrix of neighbourhoods by cell types
}
\description{
This function computes a matrix where neighbourhoods are rows and
cell types are columns. The values in the matrix indicate the
number of cells of a given type within a neighbourhood.
}
\examples{
NBHDByCTMatrix = computeNBHDByCTMatrix(delaunayNeighbours,
                                         clusters)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeNBHDVsCTSeurat}
\alias{computeNBHDVsCTSeurat}
\title{This function creates a seurat object using a neighbourhood by cell type
matrix}
\usage{
computeNBHDVsCTSeurat(
  dataMatrix,
  resolution = 0.1,
  npcs = 10,
  n.neighbors = 30L,
  transpose = FALSE,
  verbose = TRUE,
  returnType = "Seurat"
)
}
\arguments{
\item{dataMatrix}{\itemize{
\item a matrix of neighbourhoods by cell types or its
transpose.
}}

\item{resolution}{\itemize{
\item resolution for clustering (default 0.1).
}}

\item{npcs}{\itemize{
\item number of pcs used for PCA, defaults to 10.
}}

\item{n.neighbors}{\itemize{
\item number of neighbors used by UMAP, defaults to 30.
}}

\item{transpose}{\itemize{
\item defaults to FALSE.
}}

\item{verbose}{\itemize{
\item defaults to TRUE, used to limit trace if FALSE
}}

\item{returnType}{\itemize{
\item Will return a SingleCellExperiment if this is either
of SCE, SingleCellExperiment or their lower-case equivalents.  Otherwise,
returns a Seurat object
}}
}
\value{
a seurat object based on a neighbourhood by cell type matrix or its
transpose, containing clusters and UMAP. This can also be a
SingleCellExperiment depending on the parameter returnType.
}
\description{
This function creates a seurat object using a neighbourhood by cell type
matrix
}
\examples{
NBHDByCTSeurat = computeNBHDVsCTSeurat(NBHDByCTMatrix)
NBHDByCTSeurat_sce = computeNBHDVsCTSeurat(NBHDByCTMatrix,returnType='SCE')
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeNeighbourEnrichment}
\alias{computeNeighbourEnrichment}
\title{This function calculates P values for whether cell types are more frequently
neighbours than expected by chance. It does this by comparison to randomised
neighbour graphs where edges are randomised but the degree of each node is
preserved.}
\usage{
computeNeighbourEnrichment(
  spatialGraph,
  cellTypes,
  nSim = 1000,
  maxTries = 1000,
  verbose = TRUE
)
}
\arguments{
\item{spatialGraph}{\itemize{
\item a spatial graph in neighbour list format.
}}

\item{cellTypes}{\itemize{
\item named vector of cell types where names are each cell and
cell types are a factor.
}}

\item{nSim}{\itemize{
\item the number of randomised graphs to create for pvalue
calculation.
}}

\item{maxTries}{\itemize{
\item the maximum number of tries to remove self edges during
graph randomisation. If self edges are remeining this will be reported.
}}

\item{verbose}{\itemize{
\item whether to print trace.  Defaults to TRUE
}}
}
\value{
A square matrix containing upper tail p values describing whether two
cell types are more frequently found together than expected by chance.
}
\description{
This function calculates P values for whether cell types are more frequently
neighbours than expected by chance. It does this by comparison to randomised
neighbour graphs where edges are randomised but the degree of each node is
preserved.
}
\examples{
cellTypesPerCellTypePValues = computeNeighbourEnrichment(delaunayNeighbours, 
clusters, nSim = 10, verbose = FALSE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeNeighboursDelaunay}
\alias{computeNeighboursDelaunay}
\title{This function computes a spatial graph where
neighbors are identified based on Delaunay triangulation.}
\usage{
computeNeighboursDelaunay(centroids)
}
\arguments{
\item{centroids}{\itemize{
\item a dataframe containing centroids
where rownames are cellnames and the first two columns
contain x and y coordinates respectively.
}}
}
\value{
a graph in neighbour format, i.e., a data frame with
columns nodeA and nodeB.
}
\description{
This function computes a spatial graph where
neighbors are identified based on Delaunay triangulation.
}
\examples{
delaunayNeighbours = computeNeighboursDelaunay(centroids)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{computeNeighboursEuclidean}
\alias{computeNeighboursEuclidean}
\title{This function computes a spatial graph where
neighbors are identified based on euclidean distance and a
user defined threshold.}
\usage{
computeNeighboursEuclidean(centroids, threshold)
}
\arguments{
\item{centroids}{\itemize{
\item a dataframe containing centroids
where rownames are cellnames and columns contain x
and y coordinates respectively.
}}

\item{threshold}{\itemize{
\item a distance cut off to compute neighbours.
}}
}
\value{
a graph in neighbour format, i.e., a data frame with
columns nodeA and nodeB.
}
\description{
This function computes a spatial graph where
neighbors are identified based on euclidean distance and a
user defined threshold.
}
\examples{
euclideanNeighbours = computeNeighboursEuclidean(centroids,20)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{countLRInteractionsPerCell}
\alias{countLRInteractionsPerCell}
\title{This function takes a listing of the neighbouring
cells together with the presence or absence of each
ligand-receptor pair on each edge and produces a count
showing for each cell, how many neighbours it has with
that interaction either as source or as target}
\usage{
countLRInteractionsPerCell(edges, sourceOrTarget)
}
\arguments{
\item{edges}{\itemize{
\item A data frame of neighbouring cells
together with their interactions as produced by
getInteractionsOnEdges()
}}

\item{sourceOrTarget}{\itemize{
\item a character, either 'source' or
'target' telling which direction of interaction to count
}}
}
\value{
This returns a data frame with one row for each
cell and a column giving the name of that cell and the
other columns giving the counts of interactions that it
has with its neighbours.
}
\description{
This function takes a listing of the neighbouring
cells together with the presence or absence of each
ligand-receptor pair on each edge and produces a count
showing for each cell, how many neighbours it has with
that interaction either as source or as target
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{CTByNBHDSeuratExtended}
\alias{CTByNBHDSeuratExtended}
\title{CTByNBHDSeuratExtended}
\format{
A Seurat object consisting of 16 samples (cell types) and
4261 features (the neighbourhoods).

\describe{
This is a Seurat object created by taking t(NBHDByCTMatrixExtended)
as the counts.
}
}
\source{
Created from t(NBHDByCTMatrixExtended) by
computeNBHDVsCTSeurat()
}
\usage{
CTByNBHDSeuratExtended
}
\description{
A Seurat object computed from the transpose of NBHDByCTMatrixExtended.
Think of cell types "expressing" (being found in) neighbourhoods.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{CTByNBHDSeurat}
\alias{CTByNBHDSeurat}
\title{CTByNBHDSeurat}
\format{
A Seurat object consisting of 24 samples (the cell types) and
4261 features (the neighbourhoods).

\describe{
This is a Seurat object created by taking t(NBHDByCTMatrix)
as the counts.
}
}
\source{
Created from t(NBHDByCTMatrix) by
computeNBHDVsCTSeurat()
}
\usage{
CTByNBHDSeurat
}
\description{
A Seurat object computed from the transpose of NBHDByCTMatrix. Think of
cell types "expressing" (being found in) neighbourhoods.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{cullEdges}
\alias{cullEdges}
\title{This subsets edges by our chosen critera}
\usage{
cullEdges(annEdges, cutoffSpec)
}
\arguments{
\item{annEdges}{\itemize{
\item a data frame with columns nodeA, nodeB, length
and cellTypePair as produced by edgeLengthsAndCellTypePairs.
}}

\item{cutoffSpec}{\itemize{
\item This can be either a numeric value which will
be applied across all edges as an upper limit or a data frame
with columns cellTypePair and cutoff as produced by any of the
edgeCutoffsBy functions
}}
}
\value{
This returns a subset of the annotated edges
}
\description{
This subsets edges by our chosen critera
}
\examples{
annEdges =
    edgeLengthsAndCellTypePairs(delaunayNeighbours,clusters,centroids)
tolerance = 5
nbins = 15
cutoffDFWater = edgeCutoffsByWatershed(annEdges,
                                      tolerance=tolerance,
                                      nbins=nbins)
culledEdges = cullEdges(annEdges,cutoffDFWater)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{delaunayNeighbours}
\alias{delaunayNeighbours}
\title{delaunayNeighbours}
\format{
A data frame with character columns nodeA and nodeB.

\describe{
The entries in this data frame are cell names from smallXenium.
Each row represents an undirected edge in the Delaunay
triangulation of centroids.
}
}
\source{
This is computed from centroids using
computeNeighboursDelaunay()
}
\usage{
delaunayNeighbours
}
\description{
A data frame of the Delaunay triangulation of centroids of cells in
smallXenium
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{desymmetriseNN}
\alias{desymmetriseNN}
\title{This function takes the data frame of neighbor genes
and reduces it so that each undirected edge is
represented by only one directed edge.  This ensures
that randomisation does not magically split undirected
edges into two edges.}
\usage{
desymmetriseNN(NN)
}
\arguments{
\item{NN}{\itemize{
\item a dataframe containing the neighborlist
}}
}
\value{
\itemize{
\item a neighborListDF with only one directed edge per
undirected edge.
}
}
\description{
This function takes the data frame of neighbor genes
and reduces it so that each undirected edge is
represented by only one directed edge.  This ensures
that randomisation does not magically split undirected
edges into two edges.
}
\examples{
print(dim(NN))
NNN = desymmetriseNN(NN)
print(dim(NNN))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{directedHausdorfDistance}
\alias{directedHausdorfDistance}
\title{This finds the directed Hausdorf distance from A to B}
\usage{
directedHausdorfDistance(A, B)
}
\arguments{
\item{A}{\itemize{
\item an m x d matrix representing m points in
dimension d
}}

\item{B}{\itemize{
\item an n x d matrix representing n points in
dimension d
}}
}
\value{
This returns the distance of the furthest point
in A from its nearest point in B.
}
\description{
This finds the directed Hausdorf distance from A to B
}
\examples{
A = matrix(1:8,ncol=2)
B = matrix(3:16,ncol=2)
d_hausdorf = directedHausdorfDistance(A,B)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{edgeCutoffsByClustering}
\alias{edgeCutoffsByClustering}
\title{This finds proposed cutoffs for edge lengths by clustering
the lengths of the edges for each cell type pair using k-means
clustering with k  = 2}
\usage{
edgeCutoffsByClustering(annEdges)
}
\value{
This returns a data frame with columns cellTypePair and
cutoff.
}
\description{
@param annEdges - a data frame with columns nodeA, nodeB, length
and cellTypePair as produced by edgeLengthsAndCellTypePairs.
}
\examples{
annEdges =
    edgeLengthsAndCellTypePairs(delaunayNeighbours,clusters,centroids)
cutoffDF = edgeCutoffsByClustering(annEdges)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{edgeCutoffsByPercentile}
\alias{edgeCutoffsByPercentile}
\title{This finds edge cutoffs by percentile}
\usage{
edgeCutoffsByPercentile(annEdges, percentileCutoff)
}
\arguments{
\item{annEdges}{\itemize{
\item a data frame with columns nodeA, nodeB, length
and cellTypePair as produced by edgeLengthsAndCellTypePairs.
}}

\item{percentileCutof}{\itemize{
\item a numeric
}}
}
\value{
This returns a data frame with columns cellTypePair and
cutoff.
}
\description{
This finds edge cutoffs by percentile
}
\examples{
annEdges =
    edgeLengthsAndCellTypePairs(delaunayNeighbours,clusters,centroids)
cutoffDF = edgeCutoffsByPercentile(annEdges,percentileCutoff=95)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{edgeCutoffsByWatershed}
\alias{edgeCutoffsByWatershed}
\title{This finds proposed cutoffs for edge lengths by computing
the histogram of edge lengths for each cell type pair and
then using the watershed algorithm to find the hump of the
histogram containing the median.}
\usage{
edgeCutoffsByWatershed(annEdges, nbins = 15, tolerance = 10)
}
\arguments{
\item{annEdges}{\itemize{
\item a data frame with columns nodeA, nodeB, length
and cellTypePair as produced by edgeLengthsAndCellTypePairs.
}}

\item{nbins}{\itemize{
\item the number of bins for the histogram
}}

\item{tolerance}{\itemize{
\item the tolerance parameter for the watershed
algorithm.
}}
}
\value{
This returns a data frame with columns cellTypePair and
cutoff.
}
\description{
This finds proposed cutoffs for edge lengths by computing
the histogram of edge lengths for each cell type pair and
then using the watershed algorithm to find the hump of the
histogram containing the median.
}
\examples{
annEdges =
    edgeLengthsAndCellTypePairs(delaunayNeighbours,clusters,centroids)
cutoffDF = edgeCutoffsByWatershed(annEdges)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{edgeCutoffsByZScore}
\alias{edgeCutoffsByZScore}
\title{This finds edge cutoffs by z-score}
\usage{
edgeCutoffsByZScore(annEdges, zCutoff)
}
\arguments{
\item{annEdges}{\itemize{
\item a data frame with columns nodeA, nodeB, length
and cellTypePair as produced by edgeLengthsAndCellTypePairs.
}}

\item{zCutof}{\itemize{
\item a numeric
}}
}
\value{
This returns a data frame with columns cellTypePair and
cutoff.
}
\description{
This finds edge cutoffs by z-score
}
\examples{
annEdges =
    edgeLengthsAndCellTypePairs(delaunayNeighbours,clusters,centroids)
cutoffDF = edgeCutoffsByZScore(annEdges,zCutoff=1.5)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{edgeLengthPlot}
\alias{edgeLengthPlot}
\title{edgeLengthPlot}
\usage{
edgeLengthPlot(annEdges, cutoffDF, whichPairs, xLim = 100, legend = FALSE)
}
\arguments{
\item{annEdges}{\itemize{
\item A data frame as produced by
edgeLengthsAndCellTypePairs
}}

\item{cutoffDF}{\itemize{
\item A data frame with columns cellTypePair and
cutoff. This defaults to NULL in which case no cutoffs will be
plotted.
}}

\item{whichPairs}{\itemize{
\item Which cellTypePairs to plot.  If this is NULL,
we plot all pairs.  If this is a numeric, we plot only pairs
that have at least this many edges.  If this is a character
vector, we plot the pairs in this list.
}}

\item{legend}{\itemize{
\item Show legend, defaults to FALSE
}}

\item{xlim}{\itemize{
\item limits the extent of the plots. Defaults to 100.  Can
be set to NULL.
}}
}
\value{
This returns a ggplot object
}
\description{
This plots histograms of the edge lengths broken out
by the cell types of the cells they connect.  It
optionally plots a cutoff for each pair of types.
}
\examples{
annEdges = edgeLengthsAndCellTypePairs(delaunayNeighbours,
                   clusters,centroids)
cutoffDF = edgeCutoffsByPercentile(annEdges,95)
g = edgeLengthPlot(annEdges,cutoffDF,whichPairs=60)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{edgeLengthsAndCellTypePairs}
\alias{edgeLengthsAndCellTypePairs}
\title{This function annotates edges with their distance and
the types of cells they connect}
\usage{
edgeLengthsAndCellTypePairs(edges, clusters, centroids)
}
\arguments{
\item{edges}{\itemize{
\item A data frame with columns nodeA and nodeB giving the
cells of each edge
}}

\item{clusters}{\itemize{
\item the clusters of each cell
}}

\item{centroids}{\itemize{
\item the centroids of each cell
}}
}
\value{
a data frame giving the edges (as nodeA and nodeB), their
lengths and the cell type pair.
}
\description{
This function annotates edges with their distance and
the types of cells they connect
}
\examples{
annEdges = edgeLengthsAndCellTypePairs(delaunayNeighbours,
                   clusters,centroids)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{edgeNeighbours}
\alias{edgeNeighbours}
\title{edgeNeighbours}
\format{
A data frame with character columns nodeA and nodeB.

\describe{
A spatial graph where edges in the original delaunayNeighbours become nodes
and A-B edges (in the original graph) become connected to
all A- edges and all B- edges.
}
}
\source{
This is computed from delaunayNeighbours using
computeEdgeGraph()
}
\usage{
edgeNeighbours
}
\description{
A neighbour graph where nodes represent interactions between cells.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{edgeSeurat}
\alias{edgeSeurat}
\title{edgeSeurat}
\format{
A Seurat object consisting of 25518 samples (edges between cells
and 28 features (ligand-receptor pairs).

\describe{
This is a Seurat object where
each point represents an edge between cells, and spatial coordinates are the
centroids of edges between cells. The "expression matrix" is the
binarised presence/absence of an interaction (ligand receptor pair) on an edge.
}
}
\source{
Created from ligandReceptorResults by
computeEdgeSeurat()
}
\usage{
edgeSeurat
}
\description{
A Seurat object computed from ligandReceptorResults using
computeEdgeSeurat()
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{euclideanNeighbours}
\alias{euclideanNeighbours}
\title{euclideanNeighbours}
\format{
A data frame with character columns nodeA and nodeB.

\describe{
The entries in this data frame are cell names from smallXenium.
Each row represents an undirected edge in the nearest neighbour
graph using a cutoff euclidean distance of 20 \\mu m.
}
}
\source{
This is computed from centroids using
computeNeighboursEuclidean()
}
\usage{
euclideanNeighbours
}
\description{
A data frame of nearest neighbours calculated
using euclidean distance as a cutoff.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{extendedNeighboursList}
\alias{extendedNeighboursList}
\title{extendedNeighboursList}
\format{
A list of dataframes with character columns nodeA and nodeB.

\describe{
A named list of neighbour graphs, where each graph contains edges
connecting vertices of degree n. Each graph (list entry) is named according to degree n.
}
}
\source{
This is computed from delaunayNeighbours using
getExtendedNBHDs()
}
\usage{
extendedNeighboursList
}
\description{
A list of nth degree neighbour graphs calculated from delaunayNeighbours.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{extendedNeighbours}
\alias{extendedNeighbours}
\title{extendedNeighbours}
\format{
A data frame with character columns nodeA and nodeB.

\describe{
The entries in this data frame are cell names from smallXenium.
Each row represents an undirected edge in the extended neighbour
graph. Nodes are connected to all nodes up to
and including degree 4 in the original graph (delaunayNeighbours).
}
}
\source{
This is computed from extendedNeighboursList using
collapseExtendedNBHDs()
}
\usage{
extendedNeighbours
}
\description{
A neighbour graph where nodes are connected to all nodes up to
and including degree 4 in the original graph (delaunayNeighbours)
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{geneSetsVsGeneClustersPValueMatrix}
\alias{geneSetsVsGeneClustersPValueMatrix}
\title{This compares the gene clusters to other gene sets
e.g., GO, Hallmark, and determines the p-value for
their overlaps when compared to a set of background
genes.}
\usage{
geneSetsVsGeneClustersPValueMatrix(
  geneSets,
  clusterDF,
  backgroundGenes,
  adjust = FALSE
)
}
\arguments{
\item{geneSets}{\itemize{
\item a named list of gene sets
}}

\item{clusterDF}{\itemize{
\item a data frame giving the cluster
membership of each gene with columns gene and geneCluster
}}

\item{backgroundGenes}{\itemize{
\item a character vector of genes
}}

\item{adjust}{\itemize{
\item a logical deciding whether to adjust
p values.  Defaults to FALSE.
}}
}
\value{
a matrix of p-values rows correspond to the gene
sets and the columns correspond the the CatsCradle gene
clusters
}
\description{
This compares the gene clusters to other gene sets
e.g., GO, Hallmark, and determines the p-value for
their overlaps when compared to a set of background
genes.
}
\examples{
clusterDF = data.frame(gene=colnames(STranspose),
                       geneCluster=STranspose$seurat_clusters)
geneSet = intersect(hallmark[[1]],colnames(STranspose))
pvalueMatrix = geneSetsVsGeneClustersPValueMatrix(geneSet,
                                              clusterDF,
                                              colnames(STranspose))
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getAverageExpressionDF}
\alias{getAverageExpressionDF}
\title{This converts an average gene expression matrix to a
data frame.}
\usage{
getAverageExpressionDF(M)
}
\arguments{
\item{M}{\itemize{
\item An average gene expression matrix.
}}
}
\value{
A data frame with columns cellCluster, geneCluster
and average expression
}
\description{
This converts an average gene expression matrix to a
data frame.
}
\examples{
averageExpDF = getAverageExpressionDF(averageExpMatrix)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getAverageExpressionMatrix}
\alias{getAverageExpressionMatrix}
\title{This computes average expression of each gene cluster in
each cell cluster and returns the result as a matrix}
\usage{
getAverageExpressionMatrix(
  f,
  fPrime,
  v5 = T,
  clusteringName = "seurat_clusters",
  layer = "scale.data"
)
}
\arguments{
\item{f}{\itemize{
\item The Seurat object of cells, or SingleCellExperiment
to be turned into a Seurat object
}}

\item{fPrime}{\itemize{
\item The Seurat object of genes,  or SingleCellExperiment
to be turned into a Seurat object
}}

\item{v5}{\itemize{
\item A logical. Are we using Seurat v5? Defaults
to TRUE
}}

\item{clusteringName}{In many cases, this will be the cell
clustering, i.e., seurat_clusters, which is the default, but
for neighbourhood Seurat objects, this can be
neighbourhood_clusters.}

\item{layer}{\itemize{
\item layer to use for expression values
}}
}
\value{
A matrix of the average expression where the rows
correspond to cell clusters and the columns correspond to
gene clusters.
}
\description{
This computes average expression of each gene cluster in
each cell cluster and returns the result as a matrix
}
\examples{
M = getAverageExpressionMatrix(S,STranspose,layer='data')
M_sce = getAverageExpressionMatrix(S_sce,STranspose_sce,layer='data')
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{getBinarisedMatrix}
\alias{getBinarisedMatrix}
\title{This functions retrieves an expression matrix from a seurat object and
binarises it.}
\usage{
getBinarisedMatrix(obj, cutoff = 0, layer = "count")
}
\arguments{
\item{obj}{\itemize{
\item a Seurat object or SingleCellExperiment to be
turned into a Seurat object
}}

\item{cutoff}{\itemize{
\item a cutoff for binarisation. Defaults to 0.
}}

\item{layer}{\itemize{
\item layer to fetch data from. Defaults to count.
}}
}
\value{
A binarised expression matrix where rows are genes and columns are
cells.
}
\description{
This functions retrieves an expression matrix from a seurat object and
binarises it.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getClusterOrder}
\alias{getClusterOrder}
\title{This gets the clusters in their cannonical order}
\usage{
getClusterOrder(f)
}
\arguments{
\item{f}{\itemize{
\item a Seurat object with meta.data column seurat_clusters
or SingleCellExperiment to be turned into a Seurat object
}}
}
\value{
A vector of these unique values in order
}
\description{
This deals with skullduggery in which seurat_clusters
has been converted from a factor to a character or a
numeric.
}
\examples{
geneClusters = getClusterOrder(STranspose)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{getExtendedNBHDs}
\alias{getExtendedNBHDs}
\title{This function takes a nearest neighbour graph and a radius
and calculates nth degree neighbour graphs where max(n) == radius}
\usage{
getExtendedNBHDs(spatialGraph, n)
}
\arguments{
\item{spatialGraph}{\itemize{
\item a nearest neighbour graph
}}

\item{n}{\itemize{
\item the maximum degree to calculate a neighbour graph with edges
connecting vertices of degree n for.
}}
}
\value{
A named list of neighbour graphs, where each graph contains edges
connecting vertices of degree n. Each graph is named according to degree n.
}
\description{
This function takes a nearest neighbour graph and a radius
and calculates nth degree neighbour graphs where max(n) == radius
}
\examples{
extendedNeighboursList = getExtendedNBHDs(delaunayNeighbours, 4)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getGeneClusterAveragesPerCell}
\alias{getGeneClusterAveragesPerCell}
\title{This produces a matrix giving the average expression of gene
clusters in cells.  By default, it uses all cells and all gene
clusters.}
\usage{
getGeneClusterAveragesPerCell(
  f,
  fPrime,
  cells = colnames(f),
  geneClusters = getClusterOrder(fPrime),
  layer = "data"
)
}
\arguments{
\item{f}{\itemize{
\item the cell Seurat object or SingleCellExperiment to be
turned into a Seurat object
}}

\item{fPrime}{\itemize{
\item the genes Seurat object or SingleCellExperiment to be
turned into a Seurat object
}}

\item{cells}{\itemize{
\item the cells to compute this for
}}

\item{geneClusters}{\itemize{
\item the geneClusters to compute average
expression for
}}

\item{layer}{\itemize{
\item the data layer to use, defaults to 'data'
}}
}
\value{
A matrix where the rows correspond to cells, the columns
correspond to geneClusters and the entries give average expression
for each cluster in each cell
}
\description{
This produces a matrix giving the average expression of gene
clusters in cells.  By default, it uses all cells and all gene
clusters.
}
\examples{
clusterExpression = getGeneClusterAveragesPerCell(S,STranspose)
clusterExpression_sce = getGeneClusterAveragesPerCell(S_sce,STranspose_sce)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getGeneNeighbors}
\alias{getGeneNeighbors}
\title{This function gets the neighbors of a given gene
using either the gene Seurat object or its nearest
neighbor graph returned from getNearestNeighborListsSeurat}
\usage{
getGeneNeighbors(gene, NN)
}
\arguments{
\item{gene}{\itemize{
\item the gene in question
}}

\item{NN}{\itemize{
\item either the gene Seurat object or its nearest
neighbor graph as found by getNearestNeighborListsSeurat.
This can also be a SingleCellExperiment which will be converted
to a Seurat object
}}
}
\value{
the neighboring genes
}
\description{
This function gets the neighbors of a given gene
using either the gene Seurat object or its nearest
neighbor graph returned from getNearestNeighborListsSeurat
}
\examples{
library(Seurat)
neighbors = getGeneNeighbors("Ccl6",STranspose)
neighborsAgain = getGeneNeighbors("Ccl6",NN)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{getInteractionsOnEdges}
\alias{getInteractionsOnEdges}
\title{This function takes a binarised expression matrix, a set of ligand receptor
pairs and a set of edges denoting neighbouring cells and
annotates these with the ligand receptor interactions taking
place on those edges in each direction.}
\usage{
getInteractionsOnEdges(M, pairDF, spatialGraph)
}
\arguments{
\item{M}{\itemize{
\item a binarised expression matrix where rows are genes and columns
are cells.
}}

\item{pairDF}{\itemize{
\item a data frame giving the ligand-receptor pairs
}}

\item{spatialGraph}{\itemize{
\item a data frame of neighbouring
cell pairs.  Note that each row is a directed edge (A,B) so
that this data frame should have both the edge (A,B) and the
edge (B,A)
}}
}
\value{
This returns a data frame whose first two columns give
the neighbouring cells.  Each of the remaining columns is a logical
corresponding to a ligand-receptor pair telling whether the ligand
is expressed in the first cell and the receptor is expressed in the
second cell.
}
\description{
This function takes a binarised expression matrix, a set of ligand receptor
pairs and a set of edges denoting neighbouring cells and
annotates these with the ligand receptor interactions taking
place on those edges in each direction.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{getLigandReceptorNetwork}
\alias{getLigandReceptorNetwork}
\title{This function retrieves the Nichenetr ligand-
receptor network for mouse or human.}
\usage{
getLigandReceptorNetwork(species)
}
\arguments{
\item{species}{\itemize{
\item either 'human' or 'mouse'
}}
}
\value{
This returns a data frame whose first two
columns are from and to, i.e., ligand and receptor.
These are derived from the nichenetr ligand receptor
networks.
}
\description{
This function retrieves the Nichenetr ligand-
receptor network for mouse or human.
}
\examples{
lrn = getLigandReceptorNetwork('human')
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{getLigandReceptorPairsInPanel}
\alias{getLigandReceptorPairsInPanel}
\title{This functions takes an Seurat object, its species
and a ligand receptor network and subsets the ligand
receptor network to those pairs that occur in the
panel}
\usage{
getLigandReceptorPairsInPanel(
  obj,
  species,
  lrn = getLigandReceptorNetwork(species)
)
}
\arguments{
\item{obj}{\itemize{
\item a Seurat object or SingleCellExperiment to
be converted to a Seurat object
}}

\item{species}{\itemize{
\item either 'human' or 'mouse'
}}

\item{lrn}{\itemize{
\item a ligand-receptor network, i.e., a
data frame with columns from and to.  By default, it
retrieves the nichenetr ligand receptor network
}}
}
\value{
This returns a data frame with columns ligand and
receptor
}
\description{
This functions takes an Seurat object, its species
and a ligand receptor network and subsets the ligand
receptor network to those pairs that occur in the
panel
}
\examples{
lrPairs = getLigandReceptorPairsInPanel(smallXenium, "mouse")
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getNearbyGenes}
\alias{getNearbyGenes}
\title{Nearby genes}
\usage{
getNearbyGenes(
  fPrime,
  geneSet,
  radius,
  metric = "umap",
  numPCs = NULL,
  weights = FALSE
)
}
\arguments{
\item{fPrime}{\itemize{
\item a Seurat object of genes or
SingleCellExperiment to be converted to a Seurat object
}}

\item{geneSet}{\itemize{
\item set of genes
}}

\item{radius}{\itemize{
\item the distance around the given set
}}

\item{metric}{\itemize{
\item the metric to use, one of umap, tsne,
pca or nearest neighbor
}}

\item{numPCs}{\itemize{
\item used only if the metric is pca
}}

\item{weights}{\itemize{
\item whether to use edge weights in the NN case
}}
}
\value{
This returns a named vector whose values are distance
from geneSet and whose names are the nearby genes.
}
\description{
This finds the genes near a give subset using either
a dimensional reduction or the nearest neighbor graph
}
\examples{
geneSet = intersect(colnames(STranspose),hallmark[[1]])
geometricallyNearby = getNearbyGenes(STranspose,geneSet,radius=0.2,metric='umap')
combinatoriallyNearby = getNearbyGenes(STranspose,geneSet,radius=1,metric='NN')
weightedNearby = getNearbyGenes(STranspose,'Myc',radius=1,metric='NN',weights=TRUE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getNearestNeighborListsSeurat}
\alias{getNearestNeighborListsSeurat}
\title{This function extracts a shared nearest neighbor network
from a Seurat object}
\usage{
getNearestNeighborListsSeurat(f, graph = defaultGraph(f))
}
\arguments{
\item{f}{\itemize{
\item a Seurat object or SingleCellExperiment to
be converted to a Seurat object
}}

\item{graph}{\itemize{
\item which graph to extract.  Defaults to
paste0(f@active.assay,'_snn')
}}
}
\value{
\itemize{
\item This returns dataframe of neighbors:
nodeA - node names for node A
nodeB - node names for node B
weight - edge weight
}
}
\description{
This function extracts a shared nearest neighbor network
from a Seurat object
}
\examples{
NN = getNearestNeighborListsSeurat(STranspose)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getSeuratSubsetClusteringPValue}
\alias{getSeuratSubsetClusteringPValue}
\title{This function computes a p-value for the geometric
clustering of a gene set (in UMAP or PCA reduction)
based on the median distance from its complement to
the set.}
\usage{
getSeuratSubsetClusteringPValue(
  fPrime,
  geneSubset,
  numTrials = 1000,
  reduction = "UMAP",
  numPCs = 10
)
}
\arguments{
\item{fPrime}{\itemize{
\item a transposed Seurat object, i.e. a
Seurat object of genes or SingleCellExperiment to
be converted to a Seurat object
}}

\item{geneSubset}{\itemize{
\item a subset of the genes which can
be given as a character vector as a logical vector
}}

\item{numTrials}{\itemize{
\item the number of random trials to be
carried out for randomised testing. Defaults to 1000.
}}

\item{reduction}{\itemize{
\item can be 'UMAP' or 'PCA', defaults
to 'UMAP'
}}

\item{numPCs}{\itemize{
\item number of PCs to use if reduction is
'PCA'
}}
}
\value{
A p-value reporting how often a random subset
of the same size is sufficiently clustered to produce
an equally large distance from its complement.
}
\description{
This function computes a p-value for the geometric
clustering of a gene set (in UMAP or PCA reduction)
based on the median distance from its complement to
the set.
}
\examples{
geneSubset = intersect(colnames(STranspose),hallmark[[1]])
p = getSeuratSubsetClusteringPValue(STranspose,geneSubset,100)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{getSeuratSubsetClusteringStatistics}
\alias{getSeuratSubsetClusteringStatistics}
\title{This function computes statistics for the geometric
clustering of a gene set (in UMAP or PCA reduction)
based on the median distance from its complement to
the set.}
\usage{
getSeuratSubsetClusteringStatistics(
  fPrime,
  geneSubset,
  numTrials = 1000,
  reduction = "UMAP",
  numPCs = 10
)
}
\arguments{
\item{fPrime}{\itemize{
\item a transposed Seurat object, i.e. a
Seurat object of genes or SingleCellExperiment to
be converted to a Seurat object
}}

\item{geneSubset}{\itemize{
\item a subset of the genes which can
be given as a character vector as a logical vector
}}

\item{numTrials}{\itemize{
\item the number of random trials to be
carried out for randomised testing. Defaults to 1000.
}}

\item{reduction}{\itemize{
\item can be 'UMAP' or 'PCA', defaults
to 'UMAP'
}}

\item{numPCs}{\itemize{
\item number of PCs to use if reduction is
'PCA'
}}
}
\value{
A list of statistics resulting from the
testing of randomised subsets of the same size as the
given gene subset.  These include subsetDistance, the
actual median complement distance; randomSubsetDistance,
the median complement distances for randomised subsets;
pValue, computed by comparing the real and randomised
distances; and zScore, the z-distance of the actual
median distance from the mean of the randomised distances.
}
\description{
This function computes statistics for the geometric
clustering of a gene set (in UMAP or PCA reduction)
based on the median distance from its complement to
the set.
}
\examples{
geneSubset = intersect(colnames(STranspose),hallmark[[1]])
stats = getSeuratSubsetClusteringStatistics(STranspose,geneSubset,100)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{hallmark}
\alias{hallmark}
\title{hallmark}
\format{
A named list
\describe{
The mouse hallmark gene sets.
}
}
\source{
https://www.gsea-msigdb.org/gsea/msigdb/mouse/collections.jsp
}
\usage{
hallmark
}
\description{
The mouse hallmark gene sets.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{humanLRN}
\alias{humanLRN}
\title{humanLRN}
\format{
a data frame with two columns, 'from' and 'to'
\describe{A data frame with two columns, 'from' and 'to'.
Each row represents a human ligand - receptor pair.
}
}
\source{
This is derived from the nichenetr human ligand -
receptor network.
}
\usage{
humanLRN
}
\description{
A data frame giving 12019 human ligand receptor pairs
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{ligandReceptorResults}
\alias{ligandReceptorResults}
\title{ligandReceptorResults}
\format{
A list of data frames.

\describe{
A list containing:
interactionsOnEdges - a data frame whose first two columns give
the neighbouring cells and next two columns give their corresponding
clusters. Each of the remaining columns is a logical
corresponding to a ligand-receptor pair telling whether the ligand
is expressed in the first cell and the receptor is expressed in the
second cell.
totalInteractionsByCluster - a dataframe where the first column gives a
directed (sender-receiver) pair of clusters. The second column gives the
total number of edges between those clusters. The remaining columns give the
total numbers of edges on which particular ligand receptor interactions are
present.
meanInteractionsByCluster - a dataframe where the first column gives a
directed (sender-receiver) pair of clusters. The second column gives the
total number of edges between those clusters. The remaining columns give the
total numbers of edges on which particular ligand receptor interactions are
present (for that cluster pair) divided by the total number of edges between
those clusters.
simResults - a dataframe where the rownames are sender-receiver cluster pairs
and column names are ligand receptor pairs. Values give the number of
simulations for which observed values are greater than simulated values.
pValues - a dataframe where the rownames are sender-receiver cluster pairs
and column names are ligand receptor pairs. Entries are uppertail pvalues
describing whether a particular ligand receptor interaction is observed more
frequently between 2 clusters than expected.
}
}
\source{
Created from smallXenium and delaunayNeighbours by using
performLigandReceptorAnalysis(()
}
\usage{
ligandReceptorResults
}
\description{
The result of performLigandReceptorAnalysis(smallXenium, delaunayNeighbours,
"mouse", clusters,verbose=FALSE)
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{makeLRInteractionHeatmap}
\alias{makeLRInteractionHeatmap}
\title{This function takes ligandReceptorResults and plots a heatmap of -log10(pvalues).}
\usage{
makeLRInteractionHeatmap(
  ligandReceptorResults,
  clusters,
  colours = c(),
  pValCutoffClusterPair = 0.05,
  pValCutoffLigRec = 0.05,
  labelClusterPairs = TRUE
)
}
\arguments{
\item{ligandReceptorResults}{\itemize{
\item as returned by performLigandReceptorAnalysis()
}}

\item{clusters}{\itemize{
\item named vector of cell types where names are each cell and
clusters are a factor
}}

\item{colours}{\itemize{
\item a named list of colours where names are clusters. If not
specified the default pheatmap colour scheme will be used.
}}

\item{pValCutoffClusterPair}{\itemize{
\item a cutoff for showing interactions between two
clusters. A cluster pair must have at least one ligand-receptor interaction
pvalue <  pValCutoffClusterPair. Defaults to 0.05.
}}

\item{pValCutoffLigRec}{\itemize{
\item a cutoff for showing interactions between a
ligand and receptor. At least one cluster pair must have
pvalue <  pValCutoffLigRec for ligand-receptor pair. Defaults to 0.05.
}}

\item{labelClusterPairs}{\itemize{
\item show labels for cluster pairs. Defaults to TRUE.
}}
}
\value{
matrix of -log10(pvalues) that underlies the heatmap.
}
\description{
This function takes ligandReceptorResults and plots a heatmap of -log10(pvalues).
}
\examples{
ligRecMatrix = makeLRInteractionHeatmap(ligandReceptorResults, 
clusters, colours = colours, labelClusterPairs = FALSE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{makeSummedLRInteractionHeatmap}
\alias{makeSummedLRInteractionHeatmap}
\title{This function takes ligandReceptorResults and plots a heatmap of the total
number of ligand receptor interactions between clusters.}
\usage{
makeSummedLRInteractionHeatmap(
  ligandReceptorResults,
  clusters,
  type,
  logScale = TRUE
)
}
\arguments{
\item{ligandReceptorResults}{\itemize{
\item as returned by performLigandReceptorAnalysis()
}}

\item{clusters}{\itemize{
\item named vector of cell types where names are each cell and
clusters are a factor
}}

\item{type}{\itemize{
\item "total" or "mean" to plot raw total interactions or mean interactions per edge.
}}

\item{logScale}{\itemize{
\item plot heatmap using log scale (defaults to T)
}}
}
\value{
matrix of total ligand receptor interactions that underlies the heatmap.
}
\description{
This function takes ligandReceptorResults and plots a heatmap of the total
number of ligand receptor interactions between clusters.
}
\examples{
cellTypePerCellTypeLigRecMatrix = 
makeSummedLRInteractionHeatmap(ligandReceptorResults, clusters, "mean")
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{meanGeneClusterOnCellUMAP}
\alias{meanGeneClusterOnCellUMAP}
\title{Mean gene cluster on cell umap}
\usage{
meanGeneClusterOnCellUMAP(f, fPrime, geneCluster)
}
\arguments{
\item{f}{\itemize{
\item a Seurat object of cells or SingleCellExperiment to
be converted to a Seurat object
}}

\item{fPrime}{\itemize{
\item the corresponding Seurat object of genes
SingleCellExperiment to be converted to a Seurat object
}}

\item{geneCluster}{\itemize{
\item a gene cluster of fPrime
}}
}
\value{
This returns a ggplot object
}
\description{
This function paints gene expression for a
given gene cluster on cell umap.
}
\examples{
g = meanGeneClusterOnCellUMAP(S,STranspose,geneCluster=0)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{medianComplementDistance}
\alias{medianComplementDistance}
\title{This takes a set S of n points in dimension d given
by an n x d matrix and a subset A given by a logical
and returns the median distance from the complement to
the given subset.}
\usage{
medianComplementDistance(S, idx)
}
\arguments{
\item{S}{\itemize{
\item an n x d matrix representing a set of n points
in dimension d
}}

\item{idx}{\itemize{
\item a logical of length n representing a subset of
S.  This should not be the empty set or all of S.
}}
}
\value{
This returns the median distance from the complement
to the subset
}
\description{
This takes a set S of n points in dimension d given
by an n x d matrix and a subset A given by a logical
and returns the median distance from the complement to
the given subset.
}
\examples{
S = matrix(1:12,ncol=2)
idx = c(rep(FALSE,3),rep(TRUE,3))
compDist = medianComplementDistance(S,idx)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{medianComplementPValue}
\alias{medianComplementPValue}
\title{This takes a set S of n points in dimension d and a subset
A and computes a p-value for the co-localization of the subset
by comparing the median complement distance for the given set
to values of the median complement distance computed for random
subsets of the same size.}
\usage{
medianComplementPValue(S, idx, numTrials = 1000, returnTrials = FALSE)
}
\arguments{
\item{S}{\itemize{
\item an n x d matrix representing a set of n points
in dimension d
}}

\item{idx}{\itemize{
\item a logical of length n representing a subset of
S.  This should not be the empty set or all of S.
}}

\item{numTrials}{\itemize{
\item the number of random trials to perform,
defaults to 1000
}}

\item{returnTrials}{\itemize{
\item whether to report the real and random median
complement distances.
}}
}
\value{
By default this reports a p-value.  If returnTrials is set,
this returns a list giving the p-value, the actual complement distance
and the random complement distances.
}
\description{
This takes a set S of n points in dimension d and a subset
A and computes a p-value for the co-localization of the subset
by comparing the median complement distance for the given set
to values of the median complement distance computed for random
subsets of the same size.
}
\examples{
library(Seurat)
S = data.matrix(FetchData(STranspose,c('umap_1','umap_2')))
idx = colnames(STranspose) \%in\% hallmark[[1]]
mcpv = medianComplementPValue(S,idx,numTrials=100)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{moransILigandReceptor}
\alias{moransILigandReceptor}
\title{moransILigandReceptor}
\format{
A data fame containing Moran's I for ligand receptor pairs and
related pvalues.

\describe{
Moran's I values calculated for the ligand receptor pairs in edgeSeurat.
Pvalues derived using 100 permutations.
}

A data frame showing the spatial autocorrelation of the
28 ligand receptor pairs

\describe{
A data frame with rownames giving the  28 ligand-receptor pairs and columns moransI
and pValues
}
}
\source{
Created from edgeSeurat and edgeNeighbours by using runMoransI()

Computed using the function runMoransI on the object edgeSeurat and
neighbours edgeNeighbours = computeEdgeGraph(delaunayNeighbours) with 100 trials.
For more informations see the CatsCradleSpatial vignette.
}
\usage{
moransILigandReceptor

moransILigandReceptor
}
\description{
A data fame containing Moran's I for the spatial distribution of the presence
of ligand receptor pairs on edges.

Moran's I for ligand receptor pairs
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{moransI}
\alias{moransI}
\title{moransI}
\format{
A data fame containing Moran's I and related pvalues.

\describe{
Moran's I values calculated for the genes in smallXenium (using the SCT
assay). Pvalues derived using 100 permutations.
}
}
\source{
Created from smallXenium and delaunayNeighbours by using
runMoransI()
}
\usage{
moransI
}
\description{
A data fame containing Moran's I and related pvalues.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{mouseLRN}
\alias{mouseLRN}
\title{mouseLRN}
\format{
a data frame with two columns, 'from' and 'to'
\describe{A data frame with two columns, 'from' and 'to'.
Each row represents a mouse ligand - receptor pair.
}
}
\source{
This is derived from the nichenetr mouse ligand -
receptor network.
}
\usage{
mouseLRN
}
\description{
A data frame giving 11592 mouse ligand receptor pairs
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{NBHDByCTMatrixExtended}
\alias{NBHDByCTMatrixExtended}
\title{NBHDByCTMatrixExtended}
\format{
A matrix whose rows correspond to extended neighbourhoods
(and therefore, to cells) and whose columns correspond to
cell types.

\describe{
This matrix gives the counts for each of the cell types
in each extended neighbourhood.
}
}
\source{
This is computed from delaunayNeighbours and
clusters using computeNBHDByCTMatrix().
}
\usage{
NBHDByCTMatrixExtended
}
\description{
A neighbourhoods by cell types matrix giving the count
of cells of each type in each extended neighbourhood.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{NBHDByCTMatrix}
\alias{NBHDByCTMatrix}
\title{NBHDByCTMatrix}
\format{
A matrix whose rows correspond to neighbourhoods
(and therefore, to cells) and whose columns correspond to
cell types.

\describe{
This matrix gives the counts for each of the cell types
in each neighbourhood.
}
}
\source{
This is computed from delaunayNeighbours and
clusters using computeNBHDByCTMatrix().
}
\usage{
NBHDByCTMatrix
}
\description{
A neighbourhoods by cell types matrix giving the count
of cells of each type in each neighbourhood.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{NBHDByCTSeuratExtended}
\alias{NBHDByCTSeuratExtended}
\title{NBHDByCTSeuratExtended}
\format{
A Seurat object consisting of 4261 samples (the
neighbourhoods) and 24 features (the cell types).

\describe{
This is a Seurat object created by taking NBHDByCTMatrixExtended
as the counts.
}
}
\source{
Created from NBHDByCTMatrixExtended by
computeNBHDVsCTSeurat()
}
\usage{
NBHDByCTSeuratExtended
}
\description{
A Seurat object computed from NBHDByCTMatrixExtended. Think of
neighbourhoods "expressing" cell types.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{NBHDByCTSeurat}
\alias{NBHDByCTSeurat}
\title{NBHDByCTSeurat}
\format{
A Seurat object consisting of 4261 samples (the
neighbourhoods and 24 features (the cell types).

\describe{
This is a Seurat object created by taking NBHDByCTMatrix
as the counts.
}
}
\source{
Created from NBHDByCTMatrix by
computeNBHDVsCTSeurat()
}
\usage{
NBHDByCTSeurat
}
\description{
A Seurat object computed from NBHDByCTMatrix. Think of
neighbourhoods "expressing" cell types.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{nbhdsAsEdgesToNbhdsAsList}
\alias{nbhdsAsEdgesToNbhdsAsList}
\title{nbhdsAsEdgesToNbhdsAsList}
\usage{
nbhdsAsEdgesToNbhdsAsList(cells, neighbourhoods)
}
\arguments{
\item{cells}{\itemize{
\item The cells whose neighbourhoods to
extract.
}}

\item{neighbourhoods}{\itemize{
\item neighbourhoods given as a
data frame with columns nodeA and nodeB, for example
the output of collapseNeighbourhoods
}}
}
\value{
a named list with memberships of the neighbourhoods
of cells
}
\description{
This function takes a set of neighbourhoods given
by edges and turns it into a named list giving the
memberships of each neighbourhood
}
\examples{
cells = unique(c(delaunayNeighbours$nodeA,delaunayNeighbours$nodeB))
nbhdsList = nbhdsAsEdgesToNbhdsAsList(cells,delaunayNeighbours)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{neighbourhoodDiameter}
\alias{neighbourhoodDiameter}
\title{neighbourhoodDiameter}
\usage{
neighbourhoodDiameter(neighbourhoods, centroids)
}
\arguments{
\item{neighbourhoods}{\itemize{
\item a list of neighbourhoods as
returned by nbhdsAsEdgesToNbhdsAsList
}}

\item{centroids}{\itemize{
\item the centroids of the cells
}}
}
\value{
a named numeric.  The names are the names
of the list neighbourhoods and the values are the
maximum distance within each neighbourhood
}
\description{
This function takes a list of neighbourhoods and and the
centroids of the cells and finds their diameters, i.e.,
for each neighbourhood, the maximum distance between.
}
\examples{
cells = unique(c(delaunayNeighbours$nodeA,delaunayNeighbours$nodeB))
nbhds = nbhdsAsEdgesToNbhdsAsList(cells,delaunayNeighbours)
diameters = neighbourhoodDiameter(nbhds[1:100],centroids)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{NN}
\alias{NN}
\title{NN}
\format{
A data frame with columns nodeA, nodeB and weight
\describe{
This gives the weigthed edges of the nearest neighbor graph
of the genes in STranspose.
}
}
\source{
Extracted from STranspose by getNearestNeighborListsSeurat
}
\usage{
NN
}
\description{
The nearest neighbor graph of STranspose
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{orderGeneSetPValues}
\alias{orderGeneSetPValues}
\title{This orders the gene set p-values (or -log10 p-values) and
applies a cutoff (if given) to show only the significant
gene sets for each gene cluster}
\usage{
orderGeneSetPValues(M, ascending = TRUE, cutoff = NULL, nameTag = "")
}
\arguments{
\item{M}{\itemize{
\item A matrix of gene set p-values (or their logs)
to be ordered by their significance
}}

\item{ascending}{\itemize{
\item Direction in which to order the columns.
Defaults to TRUE, so that p-values will be ordered according
to decreasing significance, should be set to FALSE if ordering
-log p-value
}}

\item{cutoff}{\itemize{
\item if non-null this is used to extract only
significant cases
}}

\item{nameTag}{\itemize{
\item can be used to modify the names of the list.
}}
}
\value{
This returns a list of whose entries are data frames,
one for each gene cluster, each giving the significant gene sets
for that cluster and their significance.
}
\description{
This orders the gene set p-values (or -log10 p-values) and
applies a cutoff (if given) to show only the significant
gene sets for each gene cluster
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{performLigandReceptorAnalysis}
\alias{performLigandReceptorAnalysis}
\title{Given a seurat object, a spatial graph, clusters and species this function
identifies ligand-receptor interactions between neighbouring cells,
identifies ligand-receptor interactions within and between clusters and
calculates whether these are observed more frequently than expected by
chance.}
\usage{
performLigandReceptorAnalysis(
  obj,
  spatialGraph,
  species,
  clusters,
  nSim = 1000,
  lrn = getLigandReceptorNetwork(species),
  verbose = TRUE
)
}
\arguments{
\item{obj}{\itemize{
\item a Seurat object
}}

\item{spatialGraph}{\itemize{
\item a data frame of neighbouring
cell pairs.
}}

\item{species}{\itemize{
\item either 'human' or 'mouse'
}}

\item{clusters}{\itemize{
\item named vector of clusters where names are each cell and
clusters are a factor
}}

\item{nSim}{\itemize{
\item number of simulations to perform for p value calculation.
}}

\item{lrn}{\itemize{
\item a ligand-receptor network, i.e., a
data frame with columns from and to.  By default, it
retrieves the nichenetr ligand receptor network
}}

\item{verbose}{\itemize{
\item whether to print trace, defaults to TRUE
}}
}
\value{
A list containing:
interactionsOnEdges - a data frame whose first two columns give
the neighbouring cells and next two columns give their corresponding
clusters. Each of the remaining columns is a logical
corresponding to a ligand-receptor pair telling whether the ligand
is expressed in the first cell and the receptor is expressed in the
second cell.
totalInteractionsByCluster - a dataframe where the first column gives a
directed (sender-receiver) pair of clusters. The second column gives the
total number of edges between those clusters. The remaining columns give the
total numbers of edges on which particular ligand receptor interactions are
present.
meanInteractionsByCluster - a dataframe where the first column gives a
directed (sender-receiver) pair of clusters. The second column gives the
total number of edges between those clusters. The remaining columns give the
total numbers of edges on which particular ligand receptor interactions are
present (for that cluster pair) divided by the total number of edges between
those clusters.
simResults - a dataframe where the rownames are sender-receiver cluster pairs
and column names are ligand receptor pairs. Values give the number of
simulations for which observed values are greater than simulated values.
pValues - a dataframe where the rownames are sender-receiver cluster pairs
and column names are ligand receptor pairs. Entries are uppertail pvalues
describing whether a particular ligand receptor interaction is observed more
frequently between 2 clusters than expected.
}
\description{
Given a seurat object, a spatial graph, clusters and species this function
identifies ligand-receptor interactions between neighbouring cells,
identifies ligand-receptor interactions within and between clusters and
calculates whether these are observed more frequently than expected by
chance.
}
\examples{
performLigandReceptorAnalysis(smallXenium, delaunayNeighbours, 
                                      "mouse", clusters, nSim = 10,
                                       verbose=FALSE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{permuteMatrix}
\alias{permuteMatrix}
\title{This function permutes the rows of a matrix.}
\usage{
permuteMatrix(M)
}
\arguments{
\item{M}{\itemize{
\item a binarised expression matrix where rows are genes and columns
}}
}
\value{
This returns a matrix in which the values have been permuted within
rows.
}
\description{
This function permutes the rows of a matrix.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{predictAnnotationAllGenes}
\alias{predictAnnotationAllGenes}
\title{This function predicts the functions of all genes based
on the functions of their neighbours.}
\usage{
predictAnnotationAllGenes(
  geneSets,
  fPrime,
  radius,
  metric = "umap",
  normaliseByGeneSet = TRUE,
  normaliseByDistance = TRUE,
  normaliseToUnitVector = TRUE
)
}
\arguments{
\item{geneSets}{\itemize{
\item a set of gene sets, e.g., hallmark
}}

\item{fPrime}{\itemize{
\item a transposed Seurat object (generated with
transposeSeuratObject()) or SingleCellExperiment to
be converted to a Seurat object
}}

\item{radius}{\itemize{
\item radius of the region to use for prediction
}}

\item{metric}{\itemize{
\item reduction or NN, defaults to umap
}}

\item{normaliseByGeneSet}{\itemize{
\item normalise by size of each gene set,
defaults to TRUE
}}

\item{normaliseByDistance}{\itemize{
\item attenutate neighbour contributions
based on distance, defaults to TRUE
}}

\item{normaliseToUnitVector}{\itemize{
\item return results as unit
vectors, defaults to TRUE
}}
}
\value{
\itemize{
\item A list where names are genes and values are vectors
of gene annotations whose entries correspond to the geneSets
}
}
\description{
This function predicts the functions of all genes based
on the functions of their neighbours.
}
\examples{
predictions = predictAnnotationAllGenes(hallmark,STranspose,radius=.5)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{predictAnnotation}
\alias{predictAnnotation}
\title{This function makes annotation predictions for a
set of genes based on gene sets (e.g., hallmark)
and a CatsCradle object by considering the annotations of
its neighboring genes.}
\usage{
predictAnnotation(
  genes,
  geneSets,
  fPrime,
  radius,
  metric = "umap",
  numPCs = NULL,
  normaliseByGeneSet = TRUE,
  normaliseByDistance = TRUE,
  normaliseToUnitVector = TRUE
)
}
\arguments{
\item{genes}{\itemize{
\item a character vector of genes
}}

\item{geneSets}{\itemize{
\item a set of annotations, e.g., hallmark
or GO
}}

\item{fPrime}{\itemize{
\item a Seurat object of genes SingleCellExperiment
to be converted to a Seurat object
}}

\item{radius}{\itemize{
\item radius for prediction neighborhood
}}

\item{metric}{\itemize{
\item reduction or NN, defaults to umap
}}

\item{numPCs}{\itemize{
\item used only if reduction is pca, defaults to NULL
}}

\item{normaliseByGeneSet}{\itemize{
\item determines whether vector annotations
are normalised by gene set size.  Defaults to TRUE
}}

\item{normaliseByDistance}{\itemize{
\item determines whether neighbor
contributions are normalised by edge weight.  Defaults to
TRUE.
}}

\item{normaliseToUnitVector}{\itemize{
\item determines whether to normalise
returned values to unit length.  Defaults to TRUE
}}
}
\value{
This returns a list of prediction vectors, one vector
for each gene in genes, each vector corresponding to the sets
in geneSets
}
\description{
This function makes annotation predictions for a
set of genes based on gene sets (e.g., hallmark)
and a CatsCradle object by considering the annotations of
its neighboring genes.
}
\examples{
set.seed(100)
genes = sample(colnames(STranspose),5)
predictions = predictAnnotation(genes,hallmark,STranspose,radius=.5)
predictions_sce = predictAnnotation(genes,hallmark,STranspose_sce,radius=.5)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{predictGeneAnnotationImpl}
\alias{predictGeneAnnotationImpl}
\title{This function is the implementation for predicting
the functions of a gene based on the functions of its
neighbours.}
\usage{
predictGeneAnnotationImpl(
  gene,
  fPrime,
  genesAnno,
  radius,
  metric,
  numPCs = NULL,
  normaliseByDistance = TRUE
)
}
\arguments{
\item{gene}{\itemize{
\item gene to annotate
}}

\item{fPrime}{\itemize{
\item a Seurat object of genes or
SingleCellExperiment to be converted to a Seurat object
}}

\item{genesAnno}{\itemize{
\item genes annotated with gene sets
}}

\item{radius}{\itemize{
\item radius of neighbours to consider
}}

\item{metric}{\itemize{
\item which metric to use to discover
neighbours, can be one of 'umap', 'tsne', 'pca', 'NN',
defaults to umap
}}

\item{numPCs}{\itemize{
\item used only if metric is pca. Defaults to NULL
}}

\item{normaliseByDistance}{\itemize{
\item choose whether to normalise
contributions of neighbors by their distance, defaults to
TRUE
}}
}
\value{
This returns a named list.  The names are
the anotations that apply to the neighbour genes, the values
are the relative wieghts of the contributions.
}
\description{
This function is the implementation for predicting
the functions of a gene based on the functions of its
neighbours.
}
\examples{
genesAnno = annotateGenesByGeneSet(hallmark)
predictions = predictGeneAnnotationImpl('Myc',STranspose,genesAnno,
radius=.5,metric='umap')
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{randomiseGraph}
\alias{randomiseGraph}
\title{This function performs degree-preserving randomisation of neighbour graphs.}
\usage{
randomiseGraph(spatialGraph, maxTries = 1000)
}
\arguments{
\item{spatialGraph}{\itemize{
\item a spatial graph in neighbour list format.
}}

\item{maxTries}{\itemize{
\item the maximum number of tries to remove self edges during
graph randomisation. If self edges are remeining this will be reported.
}}
}
\value{
A randomised graph where degree from the original graph is preserved.
}
\description{
This function performs degree-preserving randomisation of neighbour graphs.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{randomiseNodeIndices}
\alias{randomiseNodeIndices}
\title{This function generates random indices for node B}
\usage{
randomiseNodeIndices(neighborListDf, n = 100, useWeights = F)
}
\arguments{
\item{neighborListDf}{\itemize{
\item a dataframe containing the neighborlist
}}

\item{n}{\itemize{
\item the number of times to randomise indices
}}

\item{useWeights}{\itemize{
\item whether to preserve edgeweights.
}}
}
\value{
\itemize{
\item a matrix with randomised indices for node B
}
}
\description{
This function generates random indices for node B
}
\examples{
NN = desymmetriseNN(NN)
randomIndices = randomiseNodeIndices(NN,10,TRUE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{readGmt}
\alias{readGmt}
\title{This function reads in gene sets in .gmt format}
\usage{
readGmt(gmtFile, addDescr = F)
}
\arguments{
\item{gmtFile}{\itemize{
\item a .gmt file containing gene sets, e.g., Hallmark of GO
}}

\item{addDescr}{\itemize{
\item include gene set description (2nd column in .gmt file) in
gene set name
}}
}
\value{
\itemize{
\item A named list of gene sets
}
}
\description{
This function reads in gene sets in .gmt format
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{runGeometricClusteringTrials}
\alias{runGeometricClusteringTrials}
\title{This runs random trials to determine the statistical
significance of the clustering of a set of points
within a larger set.}
\usage{
runGeometricClusteringTrials(S, geneSubset, numTrials)
}
\arguments{
\item{S}{\itemize{
\item a set of points given as a matrix. The rows
are the coordinates of these points
}}

\item{geneSubset}{\itemize{
\item this is either a subset of the rownames of
S or a logical whose length is nrow(S)
}}

\item{numTrials}{\itemize{
\item the number or random trials to perform
}}
}
\value{
This returns a list. subsetDistance gives the
median complement distance for the actual set,
randomSubsetDistance gives the complement distances for
the numTrials random sets, pValue gives a p-value based
on the rank of the actual distance among the random
distances and zScore gives its z-score.
}
\description{
This function takes a matrix whose rows are geometric
coordinates and a subset of these points either given
as a character vector which is a subset of the rownames
or as a logical vector.  It returns statistics on the
mean distance of the complement to the subset.
}
\examples{
library(Seurat)
S = data.matrix(FetchData(STranspose,c('umap_1','umap_2')))
geneSubset = rownames(S) \%in\% hallmark[[1]]
geneClustering = runGeometricClusteringTrials(S,geneSubset,100)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradleSpatial.R
\name{runMoransI}
\alias{runMoransI}
\title{This function takes a matrix where rows are features and columns are cells,
and a neighbourhood list, and computes Moran's I.}
\usage{
runMoransI(
  obj,
  spatialGraph,
  assay = "RNA",
  layer = "data",
  nSim = 100,
  verbose = TRUE
)
}
\arguments{
\item{obj}{\itemize{
\item a Seurat object
}}

\item{spatialGraph}{\itemize{
\item a data frame of neighbouring
cell pairs.
}}

\item{assay}{\itemize{
\item assay to pull data from, defaults to RNA.
}}

\item{layer}{\itemize{
\item layer to pull data from, defaults to data.
}}

\item{nSim}{\itemize{
\item number of simulations to perform for p value calculation.
Defaults to 100.
}}

\item{verbose}{\itemize{
\item whether to print trace, defaults to TRUE
}}
}
\value{
a dataframe containing Moran's I and p values for each feature.
}
\description{
This function takes a matrix where rows are features and columns are cells,
and a neighbourhood list, and computes Moran's I.
}
\examples{
moransI = runMoransI(smallXenium, delaunayNeighbours, assay = "SCT", 
layer = "data", nSim = 10, verbose = FALSE)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{sankeyFromMatrix}
\alias{sankeyFromMatrix}
\title{This makes a sankey graph from a matrix of average
expression.  Our "Cat's Cradle".}
\usage{
sankeyFromMatrix(
  M,
  disambiguation = c("R_", "C_"),
  fontSize = 20,
  minus = "red",
  plus = "blue",
  height = 1200,
  width = 900
)
}
\arguments{
\item{M}{\itemize{
\item a matrix of gene expression
}}

\item{disambiguation}{\itemize{
\item used to distinguish between
the row names and the column names if these overlap
}}

\item{fontSize}{\itemize{
\item defaults to 20
}}

\item{minus}{\itemize{
\item colour to use for links with negative
values
}}

\item{plus}{\itemize{
\item colour for positive values
}}

\item{height}{\itemize{
\item height in pixels, defaults to 1200
}}

\item{width}{\itemize{
\item width in pixels, defaults to 900
}}
}
\value{
A sankey graph
}
\description{
This makes a sankey graph from a matrix of average
expression.  Our "Cat's Cradle".
}
\examples{
set.seed(100)
M = matrix(runif(12)-.3,nrow=3)
rownames(M) = as.character(1:3)
colnames(M) = as.character(1:4)
S = sankeyFromMatrix(M)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{shorterHallmark}
\alias{shorterHallmark}
\title{shorterHallmark}
\format{
A named list
\describe{
The alphabetically first ten gene hallmark gene sets.
}
}
\source{
Abbreviated from hallmark
}
\usage{
shorterHallmark
}
\description{
An abbreviation of mouse hallmark gene sets.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{smallXenium}
\alias{smallXenium}
\title{smallXenium}
\format{
A Seurat object

\describe{
A spatial Seurat object subset from the Xenium object used in
https://satijalab.org/seurat/articles/seurat5_spatial_vignette_2.
}
}
\source{
This is subset from the Xenium spatial Seurat object
https://cf.10xgenomics.com/samples/xenium/1.0.2/Xenium_V1_FF_Mouse_Brain_Coronal_Subset_CTX_HP/Xenium_V1_FF_Mouse_Brain_Coronal_Subset_CTX_HP_outs.zip
to include a small region of the field of view surrounding the dentate gyrus.
}
\usage{
smallXenium
}
\description{
A spatial Seurat object of 4261 cells and 248 genes
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{S}
\alias{S}
\title{S}
\format{
A Seurat object

\describe{
A Seurat object of cells.  It includes a UMAP of the
cells and annotated clustering into cell types.
}
}
\source{
This is subset from the data associated with
https://www.nature.com/articles/s41586-021-04006-z
}
\usage{
S
}
\description{
A Seurat object of 2000 genes by 1445 cells.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{S_sce}
\alias{S_sce}
\title{S_sce}
\format{
A SingleCellExperiment object

\describe{
A SingleCellExperiment version of S.
}
}
\source{
This was made from S using as.SingleCellExperiment
}
\usage{
S_sce
}
\description{
A SingleCellExperiment object of 2000 genes by 1445 cells.
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{STranspose}
\alias{STranspose}
\title{STranspose}
\format{
A Seurat object
\describe{
This is the transpose of S. It includes a UMAP of the
genes and and their clustering into gene types.
}
}
\source{
Produced from S by transposeSeuratObject()
}
\usage{
STranspose
}
\description{
A Seurat object of 1445 cells by 2000 genes
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{STranspose_sce}
\alias{STranspose_sce}
\title{STranspose_sce}
\format{
A SingleCellExperiment object
\describe{
This is a SingleCellExperiment version of STranspose.
}
}
\source{
Produced from STranspose using as.SingleCellExperiment
together with ancillary code for copying nearest neighbour
graphs
}
\usage{
STranspose_sce
}
\description{
A SingleCellExperiment object of 1445 cells by 2000 genes
}
\keyword{datasets}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{stripGeneSet}
\alias{stripGeneSet}
\title{This function strips out non-gene information from
the beginning of GO sets, etc.}
\usage{
stripGeneSet(geneSet)
}
\arguments{
\item{geneSet}{\itemize{
\item a list of gene sets
}}
}
\value{
a named list of gene sets
}
\description{
This function strips out non-gene information from
the beginning of GO sets, etc.
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{symmetriseNN}
\alias{symmetriseNN}
\title{This symmetrises a nearest neighbors graph.}
\usage{
symmetriseNN(NN)
}
\arguments{
\item{NN}{\itemize{
\item a nearest neighbors graph as returned
by getNearestNeighborListsSeurat
}}
}
\value{
a nearest neighbors graph
}
\description{
This first checks to see if the NN graph is symmetric
and if not symmetrises it.
}
\examples{
NNStar = symmetriseNN(NN)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{symmetryCheckNN}
\alias{symmetryCheckNN}
\title{Tests whether a nearest neighbor graph is symmetric}
\usage{
symmetryCheckNN(NN)
}
\arguments{
\item{NN}{\itemize{
\item a nearest neighbor graph.  This is in the form
of a data frame  as returned by getNearestNeighborListsSeurat.
Its coloumns include nodeA and nodeB.
}}
}
\value{
TRUE or FALSE
}
\description{
The nearest neighbor relationship is not inherently
symmetric.  This tests whether the nearest neighbor graph
retrieved from a Seurat object is.
}
\examples{
symmetryTest = symmetryCheckNN(NN)
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{tagRowAndColNames}
\alias{tagRowAndColNames}
\title{This gussies up the rownames and colnames of M}
\usage{
tagRowAndColNames(M, ccTag = "CC_", gcTag = "GC_")
}
\arguments{
\item{M}{\itemize{
\item a matrix, typically the average expression matrix
}}

\item{ccTag}{\itemize{
\item a prefix for the row (cell cluster) names
}}

\item{gcTag}{\itemize{
\item a prefix for the column (gene cluster) names
}}
}
\value{
The same matrix with fancier row and col names
}
\description{
This gussies up the rownames and colnames of M
}
\examples{
averageExpMatrix = tagRowAndColNames(averageExpMatrix,
                                     'cellCluster_','geneCluster_')
}
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CatsCradle.R
\name{transposeSeuratObject}
\alias{transposeSeuratObject}
\title{Create the transpose of a Seurat object}
\usage{
transposeSeuratObject(
  f,
  active.assay = "RNA",
  npcs = 30,
  dims = 1:20,
  res = 1,
  returnType = "Seurat"
)
}
\arguments{
\item{f}{\itemize{
\item a Seurat object
}}

\item{active.assay}{\itemize{
\item the assay to use.  Defaults to 'RNA'
}}

\item{npcs}{\itemize{
\item number of principal components, defaults to 30
}}

\item{dims}{\itemize{
\item dimensions to use for umap and nearest neighbors,
defaults to 1:20
}}

\item{res}{\itemize{
\item the clustering resolution, defaults to 1
}}

\item{returnType}{\itemize{
\item Will return a SingleCellExperiment if this is either
of SCE, SingleCellExperiment or their lower-case equivalents.  Otherwise,
returns a Seurat object
}}
}
\value{
A Seurat object or SingleCellExperiment
}
\description{
This takes a Seurat object f and creates a new Seurat object whose
expression matrix is the transpose of that of f.  This can
also be a SingleCellExperiment which will be converted to a
Seurat object
}
\examples{
STranspose = transposeSeuratObject(S)
STransposeFromSCE = transposeSeuratObject(S_sce)
STransposeAsSCE = transposeSeuratObject(S,returnType='SCE')
}
